/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG JSE (https://www.swig.org).
 * Version 5.0.3
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

declare const _SWIG_enum_tag: unique symbol;

export  class TimepointInterval {

  constructor();

  constructor(startDate: Date, endDate: Date);

  constructor(date: Date);

  getStartDate(): Date;

  getEndDate(): Date;

  isEmpty(): boolean;

  isInsideInterval(month: number, year: number): boolean;

  isInsideInterval(date: Date): boolean;
}

export  class Profiler {

  constructor();

  constructor(copy: Profiler);

  reset(): void;

  millis(): number;

  micros(): number;

  nanos(): number;

  seconds(): number;

  string(): string;
}

export const AddressType_NONE: AddressType;

export const AddressType_COMMUNITY_HUMAN: AddressType;

export const AddressType_COMMUNITY_GMW: AddressType;

export const AddressType_COMMUNITY_AUF: AddressType;

export const AddressType_COMMUNITY_PROJECT: AddressType;

export const AddressType_SUBACCOUNT: AddressType;

export const AddressType_CRYPTO_ACCOUNT: AddressType;

export type AddressType = number & { readonly [_SWIG_enum_tag]: 'AddressType'; };

export const CrossGroupType_LOCAL: CrossGroupType;

export const CrossGroupType_INBOUND: CrossGroupType;

export const CrossGroupType_OUTBOUND: CrossGroupType;

export const CrossGroupType_CROSS: CrossGroupType;

export type CrossGroupType = number & { readonly [_SWIG_enum_tag]: 'CrossGroupType'; };

export const TransactionType_NONE: TransactionType;

export const TransactionType_CREATION: TransactionType;

export const TransactionType_TRANSFER: TransactionType;

export const TransactionType_COMMUNITY_FRIENDS_UPDATE: TransactionType;

export const TransactionType_REGISTER_ADDRESS: TransactionType;

export const TransactionType_DEFERRED_TRANSFER: TransactionType;

export const TransactionType_COMMUNITY_ROOT: TransactionType;

export type TransactionType = number & { readonly [_SWIG_enum_tag]: 'TransactionType'; };

export function addressTypeToString(value: AddressType): string;

export function crossGroupTypeToString(value: CrossGroupType): string;

export function transactionTypeToString(value: TransactionType): string;

export  class MemoryBlocks {

  constructor();

  constructor(n: number);

  constructor(other: MemoryBlocks);

  size(): number;

  capacity(): number;

  reserve(n: number): void;

  isEmpty(): boolean;

  clear(): void;

  add(x: MemoryBlock): void;

  get(i: number): MemoryBlock;

  set(i: number, val: MemoryBlock): void;
}

export  class MemoryBlock {

  constructor(size: Buffer);

  constructor(data: string);

  constructor(other: MemoryBlock);

  size(): number;

  data(): Buffer;

  convertToHex(): string;

  convertToBase64(variant: number): string;

  convertToBase64(): string;

  copyAsString(): string;

  calculateHash(): MemoryBlock;

 static fromHex(hex: string): MemoryBlock;

 static fromBase64(base64: string, variant: number): MemoryBlock;

 static fromBase64(base64: string): MemoryBlock;

  isEmpty(): boolean;

  equal(b: MemoryBlock): boolean;

  notEqual(b: MemoryBlock): boolean;

  lt(b: MemoryBlock): boolean;
}

export const MnemonicType_GRADIDO_BOOK_GERMAN_RANDOM_ORDER: MnemonicType;

export const MnemonicType_GRADIDO_BOOK_GERMAN_RANDOM_ORDER_FIXED_CASES: MnemonicType;

export const MnemonicType_BIP0039_SORTED_ORDER: MnemonicType;

export const MnemonicType_MAX: MnemonicType;

export type MnemonicType = number & { readonly [_SWIG_enum_tag]: 'MnemonicType'; };

export function loadCryptoKeys(cryptoAppSecret: MemoryBlock|null, serverCryptoKey: MemoryBlock|null): void;

export  class Passphrase {

  constructor(passphrase: string, wordListType: MnemonicType);

 static generate(wordListType: MnemonicType): Passphrase|null;

 static detectMnemonicWithKeyPair(passphrase: string, userKeyPair: KeyPairEd25519): MnemonicType;

 static detectMnemonic(passphrase: string): MnemonicType;

  transform(wordListType: MnemonicType): Passphrase|null;

  createClearPassphrase(): string;

 static filter(passphrase: string): string;

  checkIfValid(): boolean;

  getString(): string;
}

export  class SecretKeyCryptography {

  constructor();

  constructor(opslimit: number, memlimit: number, algo: number);

  equal(b: SecretKeyCryptography|null): boolean;

  hasKey(): boolean;

  createKey(salt_parameter: string, passwd: string): void;

  encrypt(message: MemoryBlock): MemoryBlock;

  decrypt(encryptedMessage: MemoryBlock): MemoryBlock;
}

export function ed25519DerivationTypeToString(value: Ed25519DerivationType): string;

export const Ed25519DerivationType_SOFT: Ed25519DerivationType;

export const Ed25519DerivationType_HARD: Ed25519DerivationType;

export type Ed25519DerivationType = number & { readonly [_SWIG_enum_tag]: 'Ed25519DerivationType'; };

export const ED25519_CHAIN_CODE_SIZE: number;

export  class KeyPairEd25519 {

  constructor(publicKey: MemoryBlock|null, privateKey: MemoryBlock|null, chainCode: MemoryBlock|null);

  constructor(publicKey: MemoryBlock|null, privateKey: MemoryBlock|null);

  constructor(publicKey: MemoryBlock|null);

 static create(passphrase: Passphrase|null): KeyPairEd25519|null;

 static create(seed: MemoryBlock): KeyPairEd25519|null;

 static calculatePublicKey(privateKey: MemoryBlock): MemoryBlock;

 static validatePublicKey(publicKey: MemoryBlock|null): void;

  deriveChild(index: number): KeyPairEd25519Ex;

 static getDerivationType(index: number): Ed25519DerivationType;

  sign(message: MemoryBlock): MemoryBlock;

  sign(bodyBytes: string): MemoryBlock;

  sign(message: Uint8Array): MemoryBlock;

  verify(message: string, signature: string): boolean;

  verify(message: MemoryBlock, signature: MemoryBlock): boolean;

  is3rdHighestBitClear(): boolean;

  getPublicKey(): MemoryBlock|null;

  getChainCode(): MemoryBlock|null;

  isTheSame(b: KeyPairEd25519): boolean;

  isTheSame(privkey: MemoryBlock|null): number;

  equal(b: KeyPairEd25519): boolean;

  notEqual(b: KeyPairEd25519): boolean;

  hasPrivateKey(): boolean;

  getCryptedPrivKey(password: SecretKeyCryptography): MemoryBlock;

 static normalizeBytesForce3rd(key: MemoryBlock): void;

  isNormalized(): boolean;
}

export  class KeyPairEd25519Ex extends KeyPairEd25519 {

  constructor(publicKey: MemoryBlock|null, privateKey: MemoryBlock|null, chainCode: MemoryBlock|null, derivationIndex: number);

  isChildOf(parent: KeyPairEd25519 | KeyPairEd25519Ex): boolean;

  getDerivationIndex(): number;

  getDerivationType(): Ed25519DerivationType;

  isSoftDerivated(): boolean;

  isHardDerivated(): boolean;
}

export  class AuthenticatedEncryption {

  constructor();

  constructor(ed25519KeyPair: KeyPairEd25519 | KeyPairEd25519Ex);

  constructor(privateKeyx25519: MemoryBlock|null);

  encrypt(message: Uint8Array, recipiantKey: AuthenticatedEncryption): MemoryBlock;

  encrypt(message: MemoryBlock, recipiantKey: AuthenticatedEncryption): MemoryBlock;

  encrypt(message: string, recipiantKey: AuthenticatedEncryption): MemoryBlock;

  encrypt(message: MemoryBlock, precalculatedSharedSecretIndex: number): MemoryBlock;

  decrypt(encryptedMessage: MemoryBlock, senderKey: AuthenticatedEncryption): MemoryBlock;

  decrypt(encryptedMessage: MemoryBlock, precalculatedSharedSecretIndex: number): MemoryBlock;

  precalculateSharedSecret(recipiantKey: AuthenticatedEncryption): number;

  removePrecalculatedSharedSecret(index: number): boolean;

  mPubkey: MemoryBlock|null;

  getPublicKey(): MemoryBlock|null;

  getPrivateKey(): MemoryBlock|null;

  hasPrivateKey(): boolean;
}

export function SealedBoxEncrypt(keys: AuthenticatedEncryption, message: string): MemoryBlock;

export function SealedBoxDecrypt(keys: AuthenticatedEncryption, encryptedMessage: MemoryBlock): string;

export function SealedBoxDecrypt(privateKey: MemoryBlock|null, encryptedMessage: MemoryBlock): string;

export  class GradidoUnit {

  constructor();

  constructor(gdd: number);

  constructor(stringAmount: string);

  toString(): string;

  getGradidoCent(): number;

  value(): number;

  add(other: GradidoUnit): GradidoUnit;

  sub(other: GradidoUnit): GradidoUnit;

  mul(other: GradidoUnit): GradidoUnit;

  plus(other: GradidoUnit): GradidoUnit;

  minus(other: GradidoUnit): GradidoUnit;

  times(other: GradidoUnit): GradidoUnit;

  gt(other: GradidoUnit): boolean;

  gte(other: GradidoUnit): boolean;

  lt(other: GradidoUnit): boolean;

  lte(other: GradidoUnit): boolean;

  equal(other: GradidoUnit): boolean;

  notEqual(other: GradidoUnit): boolean;

 static calculateDecayDirect(gradidoCent: number, seconds: number): number;

 static calculateCompoundInterestDirect(gradidoCent: number, seconds: number): number;

  calculateCompoundInterest(duration: number): GradidoUnit;

  calculateCompoundInterest(startTime: Date, endTime: Date): GradidoUnit;

  calculateDecay(duration: number): GradidoUnit;

  calculateDecay(startTime: Date, endTime: Date): GradidoUnit;

 static calculateDecayDurationSeconds(startTime: Date, endTime: Date): number;

 static zero(): GradidoUnit;
}

export  class SignaturePairs {

  constructor();

  constructor(n: number);

  constructor(other: SignaturePairs);

  size(): number;

  capacity(): number;

  reserve(n: number): void;

  isEmpty(): boolean;

  clear(): void;

  add(x: SignaturePair): void;

  get(i: number): SignaturePair;

  set(i: number, val: SignaturePair): void;
}

export  class TransferAmount {

  constructor(pubkeyPtr: MemoryBlock|null, amountString: string, communityId: string);

  constructor(pubkeyPtr: MemoryBlock|null, amountString: string);

  equal(other: TransferAmount): boolean;

  getPubkey(): MemoryBlock|null;

  getAmount(): GradidoUnit;

  getCommunityId(): string;
}

export  class TimestampSeconds {

  constructor();

  constructor(date: Date);

  constructor(seconds: number);

  getDate(): Date;

  getSeconds(): number;

  equal(other: TimestampSeconds): boolean;

  notEqual(other: TimestampSeconds): boolean;

  lt(other: TimestampSeconds): boolean;

  lte(other: TimestampSeconds): boolean;

  gt(other: TimestampSeconds): boolean;

  gte(other: TimestampSeconds): boolean;
}

export  class Timestamp {

  constructor();

  constructor(date: Date);

  constructor(_seconds: number, _nanos: number);

  getDate(): Date;

  getSeconds(): number;

  getNanos(): number;

  equal(other: Timestamp): boolean;

  lt(other: Timestamp): boolean;

  gt(other: Timestamp): boolean;

  lt(other: TimestampSeconds): boolean;

  gt(other: TimestampSeconds): boolean;
}

export  class SignaturePair {

  constructor();

  constructor(pubkeyPtr: MemoryBlock|null, signaturePtr: MemoryBlock|null);

  equal(other: SignaturePair): boolean;

  getPubkey(): MemoryBlock|null;

  getSignature(): MemoryBlock|null;
}

export  class SignatureMap {

  constructor(sizeHint: number);

  constructor();

  constructor(firstSignaturePair: SignaturePair, sizeHint: number);

  constructor(firstSignaturePair: SignaturePair);

  push(signaturePair: SignaturePair): void;

  clear(): void;

  getSignaturePairs(): SignaturePairs;
}

export  class CommunityFriendsUpdate {

  constructor(colorFusion: boolean);

  equal(other: CommunityFriendsUpdate): boolean;

  getColorFusion(): boolean;
}

export  class CommunityRoot {

  constructor(pubkeyPtr: MemoryBlock|null, gmwPubkeyPtr: MemoryBlock|null, aufPubkeyPtr: MemoryBlock|null);

  getInvolvedAddresses(): MemoryBlocks;

  isInvolved(publicKey: MemoryBlock|null): boolean;

  getPubkey(): MemoryBlock|null;

  getGmwPubkey(): MemoryBlock|null;

  getAufPubkey(): MemoryBlock|null;
}

export  class GradidoCreation {

  constructor(recipient: TransferAmount, targetDate: Date);

  getInvolvedAddresses(): MemoryBlocks;

  isInvolved(publicKey: MemoryBlock|null): boolean;

  getRecipient(): TransferAmount;

  getTargetDate(): TimestampSeconds;
}

export  class GradidoTransfer {

  constructor(_sender: TransferAmount, recipientPtr: MemoryBlock|null);

  equal(other: GradidoTransfer): boolean;

  getInvolvedAddresses(): MemoryBlocks;

  isInvolved(publicKey: MemoryBlock|null): boolean;

  getSender(): TransferAmount;

  getRecipient(): MemoryBlock|null;
}

export  class GradidoDeferredTransfer {

  constructor(transfer: GradidoTransfer, timeout: Date);

  getInvolvedAddresses(): MemoryBlocks;

  isInvolved(publicKey: MemoryBlock|null): boolean;

  getSenderPublicKey(): MemoryBlock|null;

  getRecipientPublicKey(): MemoryBlock|null;

  getTransfer(): GradidoTransfer;

  getTimeout(): TimestampSeconds;
}

export  class RegisterAddress {

  constructor(_addressType: AddressType, _derivationIndex: number, userPubkeyPtr: MemoryBlock|null, nameHashPtr: MemoryBlock|null, accountPubkeyPtr: MemoryBlock|null);

  constructor(_addressType: AddressType, _derivationIndex: number, userPubkeyPtr: MemoryBlock|null, nameHashPtr: MemoryBlock|null);

  constructor(_addressType: AddressType, _derivationIndex: number, userPubkeyPtr: MemoryBlock|null);

  constructor(_addressType: AddressType, _derivationIndex: number);

  constructor(_addressType: AddressType);

  equal(other: RegisterAddress): boolean;

  getInvolvedAddresses(): MemoryBlocks;

  isInvolved(publicKey: MemoryBlock|null): boolean;

  getUserPublicKey(): MemoryBlock|null;

  getAddressType(): AddressType;

  getNameHash(): MemoryBlock|null;

  getAccountPublicKey(): MemoryBlock|null;

  getDerivationIndex(): number;
}

export  class TransactionBody {

  constructor();

  constructor(_memo: string, _createdAt: Date, _versionNumber: string, _type: CrossGroupType, _otherGroup: string);

  constructor(_memo: string, _createdAt: Date, _versionNumber: string, _type: CrossGroupType);

  constructor(_memo: string, _createdAt: Date, _versionNumber: string);

  isTransfer(): boolean;

  isCreation(): boolean;

  isCommunityFriendsUpdate(): boolean;

  isRegisterAddress(): boolean;

  isDeferredTransfer(): boolean;

  isCommunityRoot(): boolean;

  getTransactionType(): TransactionType;

  isPairing(other: TransactionBody): boolean;

  isInvolved(publicKey: MemoryBlock|null): boolean;

  getTransferAmount(): TransferAmount;

  getInvolvedAddresses(): MemoryBlocks;

  getMemo(): string;

  getCreatedAt(): Timestamp;

  getVersionNumber(): string;

  getType(): CrossGroupType;

  getOtherGroup(): string;

  getTransfer(): GradidoTransfer|null;

  getCreation(): GradidoCreation|null;

  getCommunityFriendsUpdate(): CommunityFriendsUpdate|null;

  getRegisterAddress(): RegisterAddress|null;

  getDeferredTransfer(): GradidoDeferredTransfer|null;

  getCommunityRoot(): CommunityRoot|null;
}

export  class GradidoTransaction {

  constructor();

  constructor(signatureMap: SignatureMap, bodyBytes: MemoryBlock|null, paringMessageId: MemoryBlock|null);

  constructor(signatureMap: SignatureMap, bodyBytes: MemoryBlock|null);

  constructor(other: GradidoTransaction);

  getTransactionBody(): TransactionBody|null;

  isPairing(other: GradidoTransaction): boolean;

  isInvolved(publicKey: MemoryBlock|null): boolean;

  getInvolvedAddresses(): MemoryBlocks;

  getSerializedTransaction(): MemoryBlock|null;

  getFingerprint(): MemoryBlock|null;

  getSignatureMap(): SignatureMap;

  getSignatureMap(): SignatureMap;

  getBodyBytes(): MemoryBlock|null;

  getParingMessageId(): MemoryBlock|null;
}

export  class ConfirmedTransaction {

  constructor(id: number, gradidoTransaction: GradidoTransaction|null, confirmedAt: Date, versionNumber: string, messageId: MemoryBlock|null, accountBalanceString: string, previousConfirmedTransaction: ConfirmedTransaction|null);

  constructor(id: number, gradidoTransaction: GradidoTransaction|null, confirmedAt: Date, versionNumber: string, messageId: MemoryBlock|null, accountBalanceString: string);

  constructor(id: number, gradidoTransaction: GradidoTransaction|null, confirmedAt: Date, versionNumber: string, runningHash: MemoryBlock|null, messageId: MemoryBlock|null, accountBalanceString: string);

  calculateRunningHash(previousConfirmedTransaction: ConfirmedTransaction|null): MemoryBlock|null;

  calculateRunningHash(): MemoryBlock|null;

  getId(): number;

  getGradidoTransaction(): GradidoTransaction|null;

  getConfirmedAt(): TimestampSeconds;

  getVersionNumber(): string;

  getRunningHash(): MemoryBlock|null;

  getMessageId(): MemoryBlock|null;

  getAccountBalance(): GradidoUnit;
}

export  class GradidoTransactionBuilder {

  constructor();

  reset(): void;

  build(): GradidoTransaction;

  buildOutbound(): GradidoTransaction;

  buildInbound(): GradidoTransaction;

  setDeferredTransfer(transactionTransfer: GradidoTransfer, timeout: Date): GradidoTransactionBuilder;

  setDeferredTransfer(deferredTransfer: GradidoDeferredTransfer): GradidoTransactionBuilder;

  setCommunityFriendsUpdate(colorFusion: boolean): GradidoTransactionBuilder;

  setCommunityFriendsUpdate(communityFriendsUpdate: CommunityFriendsUpdate): GradidoTransactionBuilder;

  setRegisterAddress(userPubkey: MemoryBlock|null, type: AddressType, nameHash: MemoryBlock|null, accountPubkey: MemoryBlock|null): GradidoTransactionBuilder;

  setRegisterAddress(userPubkey: MemoryBlock|null, type: AddressType, nameHash: MemoryBlock|null): GradidoTransactionBuilder;

  setRegisterAddress(userPubkey: MemoryBlock|null, type: AddressType): GradidoTransactionBuilder;

  setRegisterAddress(registerAddress: RegisterAddress): GradidoTransactionBuilder;

  setTransactionCreation(recipient: TransferAmount, targetDate: Date): GradidoTransactionBuilder;

  setTransactionCreation(creation: GradidoCreation): GradidoTransactionBuilder;

  setTransactionTransfer(sender: TransferAmount, recipientPubkey: MemoryBlock|null): GradidoTransactionBuilder;

  setTransactionTransfer(transfer: GradidoTransfer): GradidoTransactionBuilder;

  setCommunityRoot(pubkey: MemoryBlock|null, gmwPubkey: MemoryBlock|null, aufPubkey: MemoryBlock|null): GradidoTransactionBuilder;

  setCommunityRoot(communityRoot: CommunityRoot): GradidoTransactionBuilder;

  setCreatedAt(createdAt: Date): GradidoTransactionBuilder;

  setMemo(memo: string): GradidoTransactionBuilder;

  setVersionNumber(versionNumber: string): GradidoTransactionBuilder;

  setTransactionBody(body: TransactionBody): GradidoTransactionBuilder;

  setTransactionBody(bodyBytes: MemoryBlock|null): GradidoTransactionBuilder;

  setSenderCommunity(senderCommunity: string): GradidoTransactionBuilder;

  setRecipientCommunity(recipientCommunity: string): GradidoTransactionBuilder;

  sign(keyPair: KeyPairEd25519|null): GradidoTransactionBuilder;

  setParentMessageId(paringMessageId: MemoryBlock|null): GradidoTransactionBuilder;

  isCrossCommunityTransaction(): boolean;

  isBodyBuildingState(): boolean;

  isCrossCommunityBuildingState(): boolean;

  isLocalCommunityBuildingState(): boolean;
}

export const DeserializeType_UNKNOWN: DeserializeType;

export const DeserializeType_TRANSACTION_BODY: DeserializeType;

export const DeserializeType_GRADIDO_TRANSACTION: DeserializeType;

export const DeserializeType_CONFIRMED_TRANSACTION: DeserializeType;

export const DeserializeType_MAX: DeserializeType;

export type DeserializeType = number & { readonly [_SWIG_enum_tag]: 'DeserializeType'; };

export function deserializeTypeToString(value: DeserializeType): string;

export  class InteractionDeserialize {

  constructor(rawData: MemoryBlock|null, hint: DeserializeType);

  constructor(rawData: MemoryBlock|null);

  run(): void;

  isGradidoTransaction(): boolean;

  isTransactionBody(): boolean;

  isConfirmedTransaction(): boolean;

  getType(): DeserializeType;

  getTransactionBody(): TransactionBody|null;

  getGradidoTransaction(): GradidoTransaction|null;

  getConfirmedTransaction(): ConfirmedTransaction|null;
}

export  class InteractionSerialize {

  constructor(body: TransactionBody);

  constructor(transaction: GradidoTransaction);

  constructor(confirmed: ConfirmedTransaction);

  constructor(signatureMap: SignatureMap);

  run(): MemoryBlock|null;
}

export  class TransactionEntries {

  constructor();

  constructor(n: number);

  constructor(other: TransactionEntries);

  size(): number;

  capacity(): number;

  reserve(n: number): void;

  isEmpty(): boolean;

  clear(): void;

  add(x: TransactionEntry|null): void;

  get(i: number): TransactionEntry|null;

  set(i: number, val: TransactionEntry|null): void;
}

export  class TransactionEntry {

  constructor();

  constructor(serializedTransaction: MemoryBlock|null);

  constructor(confirmedTransaction: ConfirmedTransaction|null);

  constructor(transactionNr: number, month: number, year: number, transactionType: TransactionType, communityId: string);

  lt(b: TransactionEntry): boolean;

  gt(b: TransactionEntry): boolean;

  getTransactionNr(): number;

  getSerializedTransaction(): MemoryBlock|null;

  getConfirmedTransaction(): ConfirmedTransaction|null;

  getMonth(): number;

  getYear(): number;

  getTransactionType(): TransactionType;

  getCoinCommunityId(): string;

  getTransactionBody(): TransactionBody|null;

  isTransfer(): boolean;

  isCreation(): boolean;

  isCommunityFriendsUpdate(): boolean;

  isRegisterAddress(): boolean;

  isDeferredTransfer(): boolean;

  isCommunityRoot(): boolean;
}

export const FilterResult_USE: FilterResult;

export const FilterResult_DISMISS: FilterResult;

export const FilterResult_STOP: FilterResult;

export type FilterResult = number & { readonly [_SWIG_enum_tag]: 'FilterResult'; };

export  class Pagination {

  constructor();

  constructor(_size: number);

  constructor(_size: number, _page: number);

  size: number;

  page: number;

  skipEntriesCount(): number;
}

export const SearchDirection_ASC: SearchDirection;

export const SearchDirection_DESC: SearchDirection;

export type SearchDirection = number & { readonly [_SWIG_enum_tag]: 'SearchDirection'; };

export function searchDirectionToString(value: SearchDirection): string;

export  class Filter {

  constructor();

  minTransactionNr: number;

  maxTransactionNr: number;

  involvedPublicKey: MemoryBlock|null;

  searchDirection: SearchDirection;

  pagination: Pagination;

  coinCommunityId: string;

  timepointInterval: TimepointInterval;

  transactionType: TransactionType;

 static LAST_TRANSACTION: Filter;

 static ALL_TRANSACTIONS: Filter;
}

export  class FilterBuilder {

  reset(): void;

  setMinTransactionNr(_minTransactionNr: number): FilterBuilder;

  setMaxTransactionNr(_maxTransactionNr: number): FilterBuilder;

  setInvolvedPublicKey(_involvedPublicKey: MemoryBlock|null): FilterBuilder;

  setSearchDirection(_searchDirection: SearchDirection): FilterBuilder;

  setPagination(_pagination: Pagination): FilterBuilder;

  setCoinCommunityId(_coinCommunityId: string): FilterBuilder;

  setTimepointInterval(_timepointInterval: TimepointInterval): FilterBuilder;

  setTransactionType(_transactionType: TransactionType): FilterBuilder;

  build(): Filter;

  getFilter(): Filter;

  constructor();
}

export  class DeferredRedeemedTransferPair {

  constructor();

  constructor(first: TransactionEntry|null, second: TransactionEntry|null);

  constructor(other: DeferredRedeemedTransferPair);

  first: TransactionEntry|null;

  second: TransactionEntry|null;
}

export abstract class Abstract {

  addGradidoTransaction(gradidoTransaction: GradidoTransaction|null, messageId: MemoryBlock|null, confirmedAt: Date): boolean;

  findAll(filter: Filter): TransactionEntries;

  findAll(): TransactionEntries;

  findOne(filter: Filter): TransactionEntry|null;

  findOne(): TransactionEntry|null;

  findTimeoutedDeferredTransfersInRange(senderPublicKey: MemoryBlock|null, timepointInterval: TimepointInterval, maxTransactionNr: number): TransactionEntries;

  findRedeemedDeferredTransfersInRange(senderPublicKey: MemoryBlock|null, timepointInterval: TimepointInterval, maxTransactionNr: number): any;

  getAddressType(filter: Filter): AddressType;

  getAddressType(): AddressType;

  getTransactionForId(transactionId: number): TransactionEntry|null;

  findByMessageId(messageId: MemoryBlock|null, filter: Filter): TransactionEntry|null;

  findByMessageId(messageId: MemoryBlock|null): TransactionEntry|null;

  getCommunityId(): string;

  getStartDate(): Date;
}

export  class InMemoryBlockchain extends Abstract {

  clear(): void;

  exit(): void;

  addGradidoTransaction(gradidoTransaction: GradidoTransaction|null, messageId: MemoryBlock|null, confirmedAt: Date): boolean;

  getSortedTransactions(): TransactionEntries;

  findAll(filter: Filter): TransactionEntries;

  findAll(): TransactionEntries;

  findTimeoutedDeferredTransfersInRange(senderPublicKey: MemoryBlock|null, timepointInterval: TimepointInterval, maxTransactionNr: number): TransactionEntries;

  findRedeemedDeferredTransfersInRange(senderPublicKey: MemoryBlock|null, timepointInterval: TimepointInterval, maxTransactionNr: number): any;

  getTransactionForId(transactionId: number): TransactionEntry|null;

  findByMessageId(messageId: MemoryBlock|null, filter: Filter): TransactionEntry|null;

  findByMessageId(messageId: MemoryBlock|null): TransactionEntry|null;
}

export  class InMemoryBlockchainProvider {

 static getInstance(): InMemoryBlockchainProvider;

  clear(): void;

  findBlockchain(communityId: string): InMemoryBlockchain|null;
}

export const BodyBytesType_BASE64: BodyBytesType;

export const BodyBytesType_HEX: BodyBytesType;

export const BodyBytesType_JSON: BodyBytesType;

export type BodyBytesType = number & { readonly [_SWIG_enum_tag]: 'BodyBytesType'; };

export function bodyBytesTypeToString(value: BodyBytesType): string;

export  class InteractionToJson {

  constructor(body: TransactionBody);

  constructor(gradidoTransaction: GradidoTransaction, format: BodyBytesType);

  constructor(gradidoTransaction: GradidoTransaction);

  constructor(confirmedTransaction: ConfirmedTransaction, format: BodyBytesType);

  constructor(confirmedTransaction: ConfirmedTransaction);

  constructor(filter: Filter);

  run(pretty: boolean): string;

  run(): string;
}

export  class InteractionCalculateAccountBalance {

  constructor(blockchain: Abstract | InMemoryBlockchain);

  run(gradidoTransaction: GradidoTransaction|null, confirmedAt: Date, id: number): GradidoUnit;

  run(publicKey: MemoryBlock|null, balanceDate: Date, maxTransactionNr: number, coinCommunityId: string): GradidoUnit;

  run(publicKey: MemoryBlock|null, balanceDate: Date, maxTransactionNr: number): GradidoUnit;

  run(publicKey: MemoryBlock|null, balanceDate: Date): GradidoUnit;
}

export const ValidateType_SINGLE: ValidateType;

export const ValidateType_PREVIOUS: ValidateType;

export const ValidateType_MONTH_RANGE: ValidateType;

export const ValidateType_PAIRED: ValidateType;

export const ValidateType_ACCOUNT: ValidateType;

export const ValidateType_CONNECTED_GROUP: ValidateType;

export const ValidateType_CONNECTED_BLOCKCHAIN: ValidateType;

export type ValidateType = number & { readonly [_SWIG_enum_tag]: 'ValidateType'; };

export function validateTypeToString(value: ValidateType): string;

export  class InteractionValidate {

  constructor(body: TransactionBody);

  constructor(body: GradidoTransaction);

  constructor(body: ConfirmedTransaction);

  run(type: ValidateType, communityId: string, blockchainProvider: AbstractBlockchainProvider | InMemoryBlockchainProvider): void;

  run(type: ValidateType, communityId: string): void;

  run(type: ValidateType): void;

  run(): void;

  setSenderPreviousConfirmedTransaction(senderPreviousConfirmedTransaction: ConfirmedTransaction|null): void;

  setRecipientPreviousConfirmedTransaction(recipientPreviousConfirmedTransaction: ConfirmedTransaction|null): void;
}


