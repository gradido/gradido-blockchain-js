/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG JSE (https://www.swig.org).
 * Version 5.0.3
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

declare const _SWIG_enum_tag: unique symbol;

export const GRADIDO_TRANSACTION_BODY_V3_3_VERSION_STRING: string;

export const GRADIDO_CONFIRMED_TRANSACTION_V3_3_VERSION_STRING: string;

export const AddressType_NONE: AddressType;

export const AddressType_COMMUNITY_HUMAN: AddressType;

export const AddressType_COMMUNITY_GMW: AddressType;

export const AddressType_COMMUNITY_AUF: AddressType;

export const AddressType_COMMUNITY_PROJECT: AddressType;

export const AddressType_SUBACCOUNT: AddressType;

export const AddressType_CRYPTO_ACCOUNT: AddressType;

export type AddressType = number & { readonly [_SWIG_enum_tag]: 'AddressType'; };

export const CrossGroupType_LOCAL: CrossGroupType;

export const CrossGroupType_INBOUND: CrossGroupType;

export const CrossGroupType_OUTBOUND: CrossGroupType;

export const CrossGroupType_CROSS: CrossGroupType;

export type CrossGroupType = number & { readonly [_SWIG_enum_tag]: 'CrossGroupType'; };

export const TransactionType_NONE: TransactionType;

export const TransactionType_CREATION: TransactionType;

export const TransactionType_TRANSFER: TransactionType;

export const TransactionType_COMMUNITY_FRIENDS_UPDATE: TransactionType;

export const TransactionType_REGISTER_ADDRESS: TransactionType;

export const TransactionType_DEFERRED_TRANSFER: TransactionType;

export const TransactionType_COMMUNITY_ROOT: TransactionType;

export type TransactionType = number & { readonly [_SWIG_enum_tag]: 'TransactionType'; };

export  class MemoryBlocks {

  constructor();

  constructor(n: number);

  constructor(other: any);

  size(): number;

  capacity(): number;

  reserve(n: number): void;

  isEmpty(): boolean;

  clear(): void;

  add(x: any): void;

  get(i: number): any;

  set(i: number, val: any): void;
}

export  class MemoryBlock {

  constructor(size: Uint8Array);

  constructor(other: MemoryBlock);

  size(): number;

  data(): Uint8Array;

  convertToHex(): string;

  convertToBase64(variant: number): string;

  convertToBase64(): string;

  copyAsString(): string;

  calculateHash(): MemoryBlock;

 static fromHex(hex: string): MemoryBlock;

 static fromBase64(base64: string, variant: number): MemoryBlock;

 static fromBase64(base64: string): MemoryBlock;

  isEmpty(): boolean;

  equal(b: MemoryBlock): boolean;

  notEqual(b: MemoryBlock): boolean;

  lt(b: MemoryBlock): boolean;
}

export  class SecretKeyCryptography {

  constructor();

  constructor(opslimit: number, memlimit: number, algo: number);

  equal(b: SecretKeyCryptography): boolean;

  hasKey(): boolean;

  createKey(salt_parameter: string, passwd: string): void;

  encrypt(message: MemoryBlock): MemoryBlock;

  decrypt(encryptedMessage: MemoryBlock): MemoryBlock;
}

export  class GradidoUnit {

  constructor();

  constructor(gddCent: number);

  constructor(gdd: number);

  constructor(stringAmount: string);

  toString(): string;

  getGradidoCent(): number;

  value(): number;

  add(other: GradidoUnit): GradidoUnit;

  sub(other: GradidoUnit): GradidoUnit;

  mul(other: GradidoUnit): GradidoUnit;

  gt(other: GradidoUnit): boolean;

  gte(other: GradidoUnit): boolean;

  lt(other: GradidoUnit): boolean;

  lte(other: GradidoUnit): boolean;

  equal(other: GradidoUnit): boolean;

  notEqual(other: GradidoUnit): boolean;

 static calculateDecay(gradidoCent: number, seconds: number): number;

  calculateDecay(duration: number): GradidoUnit;

  calculateDecay(startTime: Date, endTime: Date): GradidoUnit;

 static calculateDecayDurationSeconds(startTime: Date, endTime: Date): number;

 static zero(): GradidoUnit;
}

export  class SignaturePairs {

  constructor();

  constructor(n: number);

  constructor(other: any);

  size(): number;

  capacity(): number;

  reserve(n: number): void;

  isEmpty(): boolean;

  clear(): void;

  add(x: any): void;

  get(i: number): any;

  set(i: number, val: any): void;
}

export  class SignaturePair {

  constructor();

  constructor(pubkeyPtr: MemoryBlock, signaturePtr: MemoryBlock);

  pubkey: MemoryBlock;

  signature: MemoryBlock;

  equal(other: SignaturePair): boolean;
}

export  class SignatureMap {

  constructor(sizeHint: number);

  constructor();

  constructor(firstSignaturePair: SignaturePair, sizeHint: number);

  constructor(firstSignaturePair: SignaturePair);

  push(signaturePair: SignaturePair): void;

  signaturePairs: SignaturePairs;
}

export  class TimestampSeconds {

  constructor();

  constructor(date: Date);

  constructor(_seconds: number);

  getAsTimepoint(): Date;

  equal(other: TimestampSeconds): boolean;

  notEqual(other: TimestampSeconds): boolean;

  lt(other: TimestampSeconds): boolean;

  lte(other: TimestampSeconds): boolean;

  gt(other: TimestampSeconds): boolean;

  gte(other: TimestampSeconds): boolean;

  seconds: number;
}

export  class Timestamp {

  constructor();

  constructor(date: Date);

  constructor(_seconds: number, _nanos: number);

  getAsTimepoint(): Date;

  equal(other: Timestamp): boolean;

  lt(other: Timestamp): boolean;

  gt(other: Timestamp): boolean;

  lt(other: TimestampSeconds): boolean;

  gt(other: TimestampSeconds): boolean;

  seconds: number;

  nanos: number;
}

export  class TransferAmount {

  constructor(pubkeyPtr: MemoryBlock, amountString: string, communityId: string);

  constructor(pubkeyPtr: MemoryBlock, amountString: string);

  equal(other: TransferAmount): boolean;

  pubkey: MemoryBlock;

  amount: GradidoUnit;

  communityId: string;
}

export  class CommunityFriendsUpdate {

  constructor(_colorFusion: boolean);

  equal(other: CommunityFriendsUpdate): boolean;

  colorFusion: boolean;
}

export  class CommunityRoot {

  constructor(pubkeyPtr: MemoryBlock, gmwPubkeyPtr: MemoryBlock, aufPubkeyPtr: MemoryBlock);

  getInvolvedAddresses(): MemoryBlocks;

  isInvolved(publicKey: MemoryBlock): boolean;

  pubkey: MemoryBlock;

  gmwPubkey: MemoryBlock;

  aufPubkey: MemoryBlock;
}

export  class GradidoCreation {

  constructor(_recipient: TransferAmount, _targetDate: Date);

  getInvolvedAddresses(): MemoryBlocks;

  isInvolved(publicKey: MemoryBlock): boolean;

  recipient: TransferAmount;

  targetDate: TimestampSeconds;
}

export  class GradidoTransfer {

  constructor(_sender: TransferAmount, recipientPtr: MemoryBlock);

  equal(other: GradidoTransfer): boolean;

  getInvolvedAddresses(): MemoryBlocks;

  isInvolved(publicKey: MemoryBlock): boolean;

  sender: TransferAmount;

  recipient: MemoryBlock;
}

export  class GradidoDeferredTransfer {

  constructor(_transfer: GradidoTransfer, _timeout: Date);

  getInvolvedAddresses(): MemoryBlocks;

  isInvolved(publicKey: MemoryBlock): boolean;

  getSenderPublicKey(): MemoryBlock;

  getRecipientPublicKey(): MemoryBlock;

  transfer: GradidoTransfer;

  timeout: TimestampSeconds;
}

export  class RegisterAddress {

  constructor(_addressType: AddressType, _derivationIndex: number, userPubkeyPtr: MemoryBlock, nameHashPtr: MemoryBlock, accountPubkeyPtr: MemoryBlock);

  constructor(_addressType: AddressType, _derivationIndex: number, userPubkeyPtr: MemoryBlock, nameHashPtr: MemoryBlock);

  constructor(_addressType: AddressType, _derivationIndex: number, userPubkeyPtr: MemoryBlock);

  constructor(_addressType: AddressType, _derivationIndex: number);

  constructor(_addressType: AddressType);

  equal(other: RegisterAddress): boolean;

  getInvolvedAddresses(): MemoryBlocks;

  isInvolved(publicKey: MemoryBlock): boolean;

  userPubkey: MemoryBlock;

  addressType: AddressType;

  nameHash: MemoryBlock;

  accountPubkey: MemoryBlock;

  derivationIndex: number;
}

export  class TransactionBody {

  constructor();

  constructor(_memo: string, _createdAt: Date, _versionNumber: string, _type: CrossGroupType, _otherGroup: string);

  constructor(_memo: string, _createdAt: Date, _versionNumber: string, _type: CrossGroupType);

  constructor(_memo: string, _createdAt: Date, _versionNumber: string);

  isTransfer(): boolean;

  isCreation(): boolean;

  isCommunityFriendsUpdate(): boolean;

  isRegisterAddress(): boolean;

  isDeferredTransfer(): boolean;

  isCommunityRoot(): boolean;

  getTransactionType(): TransactionType;

  isPairing(other: TransactionBody): boolean;

  isInvolved(publicKey: MemoryBlock): boolean;

  getTransferAmount(): TransferAmount;

  getInvolvedAddresses(): MemoryBlocks;

  memo: string;

  createdAt: Timestamp;

  versionNumber: string;

  type: CrossGroupType;

  otherGroup: string;

  transfer: GradidoTransfer;

  creation: GradidoCreation;

  communityFriendsUpdate: CommunityFriendsUpdate;

  registerAddress: RegisterAddress;

  deferredTransfer: GradidoDeferredTransfer;

  communityRoot: CommunityRoot;
}

export  class GradidoTransaction {

  constructor();

  constructor(signatureMap: SignatureMap, bodyBytes: MemoryBlock, paringMessageId: MemoryBlock);

  constructor(signatureMap: SignatureMap, bodyBytes: MemoryBlock);

  constructor(other: GradidoTransaction);

  signatureMap: SignatureMap;

  bodyBytes: MemoryBlock;

  paringMessageId: MemoryBlock;

  getTransactionBody(): TransactionBody;

  isPairing(other: GradidoTransaction): boolean;

  isInvolved(publicKey: MemoryBlock): boolean;

  getInvolvedAddresses(): MemoryBlocks;

  getSerializedTransaction(): MemoryBlock;

  getFingerprint(): MemoryBlock;
}

export  class ConfirmedTransaction {

  constructor(id: number, gradidoTransaction: GradidoTransaction, confirmedAt: Date, versionNumber: string, runningHash: MemoryBlock, messageId: MemoryBlock, accountBalanceString: string);

  calculateRunningHash(previousConfirmedTransaction: ConfirmedTransaction): MemoryBlock;

  calculateRunningHash(): MemoryBlock;

  id: number;

  gradidoTransaction: GradidoTransaction;

  confirmedAt: TimestampSeconds;

  versionNumber: string;

  runningHash: MemoryBlock;

  messageId: MemoryBlock;

  accountBalance: GradidoUnit;
}

export  class TransactionBodyBuilder {

  constructor();

  reset(): void;

  build(): TransactionBody;

  setDeferredTransfer(senderPubkey: MemoryBlock, amountGddCent: string, communityId: string, recipientPubkey: MemoryBlock, timeout: Date): TransactionBodyBuilder;

  setCommunityFriendsUpdate(colorFusion: boolean): TransactionBodyBuilder;

  setRegisterAddress(userPubkey: MemoryBlock, type: AddressType, nameHash: MemoryBlock, accountPubkey: MemoryBlock): TransactionBodyBuilder;

  setRegisterAddress(userPubkey: MemoryBlock, type: AddressType, nameHash: MemoryBlock): TransactionBodyBuilder;

  setRegisterAddress(userPubkey: MemoryBlock, type: AddressType): TransactionBodyBuilder;

  setTransactionCreation(recipientPubkey: MemoryBlock, amountGddCent: string, targetDate: Date): TransactionBodyBuilder;

  setTransactionTransfer(senderPubkey: MemoryBlock, amountGddCent: string, communityId: string, recipientPubkey: MemoryBlock): TransactionBodyBuilder;

  setCommunityRoot(pubkey: MemoryBlock, gmwPubkey: MemoryBlock, aufPubkey: MemoryBlock): TransactionBodyBuilder;

  setCreatedAt(createdAt: Date): TransactionBodyBuilder;

  setMemo(memo: string): TransactionBodyBuilder;

  setCrossGroupType(type: CrossGroupType): TransactionBodyBuilder;

  setOtherGroup(otherGroup: string): TransactionBodyBuilder;
}

export  class GradidoTransactionBuilder {

  constructor();

  reset(): void;

  build(): GradidoTransaction;

  setTransactionBody(body: TransactionBody): GradidoTransactionBuilder;

  addSignaturePair(publicKey: MemoryBlock, signature: MemoryBlock): GradidoTransactionBuilder;

  sign(keyPair: any): GradidoTransactionBuilder;

  setParentMessageId(paringMessageId: MemoryBlock): GradidoTransactionBuilder;
}


