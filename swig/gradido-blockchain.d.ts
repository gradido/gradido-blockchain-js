/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG JSE (https://www.swig.org).
 * Version 5.0.3
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

declare const _SWIG_enum_tag: unique symbol;

export const GRADIDO_TRANSACTION_BODY_V3_3_VERSION_STRING: string;

export const GRADIDO_CONFIRMED_TRANSACTION_V3_3_VERSION_STRING: string;

export const AddressType_NONE: AddressType;

export const AddressType_COMMUNITY_HUMAN: AddressType;

export const AddressType_COMMUNITY_GMW: AddressType;

export const AddressType_COMMUNITY_AUF: AddressType;

export const AddressType_COMMUNITY_PROJECT: AddressType;

export const AddressType_SUBACCOUNT: AddressType;

export const AddressType_CRYPTO_ACCOUNT: AddressType;

export type AddressType = number & { readonly [_SWIG_enum_tag]: 'AddressType'; };

export const CrossGroupType_LOCAL: CrossGroupType;

export const CrossGroupType_INBOUND: CrossGroupType;

export const CrossGroupType_OUTBOUND: CrossGroupType;

export const CrossGroupType_CROSS: CrossGroupType;

export type CrossGroupType = number & { readonly [_SWIG_enum_tag]: 'CrossGroupType'; };

export const TransactionType_NONE: TransactionType;

export const TransactionType_CREATION: TransactionType;

export const TransactionType_TRANSFER: TransactionType;

export const TransactionType_COMMUNITY_FRIENDS_UPDATE: TransactionType;

export const TransactionType_REGISTER_ADDRESS: TransactionType;

export const TransactionType_DEFERRED_TRANSFER: TransactionType;

export const TransactionType_COMMUNITY_ROOT: TransactionType;

export type TransactionType = number & { readonly [_SWIG_enum_tag]: 'TransactionType'; };

export  class GradidoUnit {

  constructor();

  constructor(gddCent: number);

  constructor(gdd: number);

  constructor(stringAmount: string);

  toString(): string;

  getGradidoCent(): number;

  value(): number;

  add(other: GradidoUnit): GradidoUnit;

  sub(other: GradidoUnit): GradidoUnit;

  mul(other: GradidoUnit): GradidoUnit;

  clone(other: GradidoUnit): GradidoUnit;

  gt(other: GradidoUnit): boolean;

  gte(other: GradidoUnit): boolean;

  lt(other: GradidoUnit): boolean;

  lte(other: GradidoUnit): boolean;

  equal(other: GradidoUnit): boolean;

  notEqual(other: GradidoUnit): boolean;

 static calculateDecay(gradidoCent: number, seconds: number): number;

  calculateDecay(duration: number): GradidoUnit;

  calculateDecay(startTime: Date, endTime: Date): GradidoUnit;

 static calculateDecayDurationSeconds(startTime: Date, endTime: Date): number;

 static zero(): GradidoUnit;
}

export  class Block {

  constructor(size: number);

  constructor(size: number, data: any);

  constructor(data: any);

  constructor(data: any);

  constructor(data: string);

  constructor(other: Block);

  constructor(other: Block);

  constructor(other: Block);

  clone(other: Block): Block;

  size(): number;

  data(): any;

  data(): any;

  span(): any;

  data(startIndex: number): any;

  data(startIndex: number): any;

  convertToHex(): string;

  convertToBase64(variant: number): string;

  convertToBase64(): string;

  copyAsString(): string;

  copyAsVector(): any;

  calculateHash(): Block;

 static fromHex(hex: string): Block;

 static fromHex(hexString: string, stringSize: number): Block;

 static fromBase64(base64: string, variant: number): Block;

 static fromBase64(base64: string): Block;

 static fromBase64(base64String: string, size: number, variant: number): Block;

  isTheSame(b: Block): boolean;

  isTheSame(b: Block): boolean;

  isEmpty(): boolean;

  equal(b: Block): boolean;

  notEqual(b: Block): boolean;

  lt(b: Block): boolean;
}

export  class ConstBlockPtrComparator {

  call(a: Block, b: Block): boolean;

  constructor();
}

export  class SignaturePair {

  constructor(pubkeyPtr: Block, signaturePtr: Block);

  pubkey: Block;

  signature: Block;

  equal(other: SignaturePair): boolean;
}

export  class SignatureMap {

  constructor(sizeHint: number);

  constructor();

  constructor(firstSignaturePair: SignaturePair, sizeHint: number);

  constructor(firstSignaturePair: SignaturePair);

  push(signaturePair: SignaturePair): void;

  signaturePairs: any;
}

export  class TimestampSeconds {

  constructor();

  constructor(date: Date);

  constructor(_seconds: number);

  getAsTimepoint(): Date;

  equal(other: TimestampSeconds): boolean;

  notEqual(other: TimestampSeconds): boolean;

  lt(other: TimestampSeconds): boolean;

  lte(other: TimestampSeconds): boolean;

  gt(other: TimestampSeconds): boolean;

  gte(other: TimestampSeconds): boolean;

  seconds: number;
}

export  class Timestamp {

  constructor();

  constructor(date: Date);

  constructor(_seconds: number, _nanos: number);

  getAsTimepoint(): Date;

  equal(other: Timestamp): boolean;

  lt(other: Timestamp): boolean;

  gt(other: Timestamp): boolean;

  lt(other: TimestampSeconds): boolean;

  gt(other: TimestampSeconds): boolean;

  seconds: number;

  nanos: number;
}

export  class TransferAmount {

  constructor(pubkeyPtr: Block, amountString: string, communityId: string);

  constructor(pubkeyPtr: Block, amountString: string);

  equal(other: TransferAmount): boolean;

  pubkey: Block;

  amount: GradidoUnit;

  communityId: string;
}

export  class CommunityFriendsUpdate {

  constructor(_colorFusion: boolean);

  equal(other: CommunityFriendsUpdate): boolean;

  colorFusion: boolean;
}

export  class CommunityRoot {

  constructor(pubkeyPtr: Block, gmwPubkeyPtr: Block, aufPubkeyPtr: Block);

  getInvolvedAddresses(): any;

  isInvolved(publicKey: Block): boolean;

  pubkey: Block;

  gmwPubkey: Block;

  aufPubkey: Block;
}

export  class GradidoCreation {

  constructor(_recipient: TransferAmount, _targetDate: Date);

  getInvolvedAddresses(): any;

  isInvolved(publicKey: Block): boolean;

  recipient: TransferAmount;

  targetDate: TimestampSeconds;
}

export  class GradidoTransfer {

  constructor(_sender: TransferAmount, recipientPtr: Block);

  equal(other: GradidoTransfer): boolean;

  getInvolvedAddresses(): any;

  isInvolved(publicKey: Block): boolean;

  sender: TransferAmount;

  recipient: Block;
}

export  class GradidoDeferredTransfer {

  constructor(_transfer: GradidoTransfer, _timeout: Date);

  getInvolvedAddresses(): any;

  isInvolved(publicKey: Block): boolean;

  getSenderPublicKey(): Block;

  getRecipientPublicKey(): Block;

  transfer: GradidoTransfer;

  timeout: TimestampSeconds;
}

export  class RegisterAddress {

  constructor(_addressType: AddressType, _derivationIndex: number, userPubkeyPtr: Block, nameHashPtr: Block, accountPubkeyPtr: Block);

  constructor(_addressType: AddressType, _derivationIndex: number, userPubkeyPtr: Block, nameHashPtr: Block);

  constructor(_addressType: AddressType, _derivationIndex: number, userPubkeyPtr: Block);

  constructor(_addressType: AddressType, _derivationIndex: number);

  constructor(_addressType: AddressType);

  equal(other: RegisterAddress): boolean;

  getInvolvedAddresses(): any;

  isInvolved(publicKey: Block): boolean;

  userPubkey: Block;

  addressType: AddressType;

  nameHash: Block;

  accountPubkey: Block;

  derivationIndex: number;
}

export  class TransactionBody {

  constructor();

  constructor(_memo: string, _createdAt: Date, _versionNumber: string, _type: CrossGroupType, _otherGroup: string);

  constructor(_memo: string, _createdAt: Date, _versionNumber: string, _type: CrossGroupType);

  constructor(_memo: string, _createdAt: Date, _versionNumber: string);

  isTransfer(): boolean;

  isCreation(): boolean;

  isCommunityFriendsUpdate(): boolean;

  isRegisterAddress(): boolean;

  isDeferredTransfer(): boolean;

  isCommunityRoot(): boolean;

  getTransactionType(): TransactionType;

  isPairing(other: TransactionBody): boolean;

  isInvolved(publicKey: Block): boolean;

  getTransferAmount(): TransferAmount;

  getInvolvedAddresses(): any;

  memo: string;

  createdAt: Timestamp;

  versionNumber: string;

  type: CrossGroupType;

  otherGroup: string;

  transfer: GradidoTransfer;

  creation: GradidoCreation;

  communityFriendsUpdate: CommunityFriendsUpdate;

  registerAddress: RegisterAddress;

  deferredTransfer: GradidoDeferredTransfer;

  communityRoot: CommunityRoot;
}

export  class GradidoTransaction {

  constructor();

  constructor(signatureMap: SignatureMap, bodyBytes: Block, paringMessageId: Block);

  constructor(signatureMap: SignatureMap, bodyBytes: Block);

  constructor(other: GradidoTransaction);

  signatureMap: SignatureMap;

  bodyBytes: Block;

  paringMessageId: Block;

  getTransactionBody(): any;

  isPairing(other: GradidoTransaction): boolean;

  isInvolved(publicKey: Block): boolean;

  getInvolvedAddresses(): any;

  getSerializedTransaction(): Block;

  getFingerprint(): Block;
}

export  class ConfirmedTransaction {

  constructor(id: number, gradidoTransaction: any, confirmedAt: Date, versionNumber: string, runningHash: Block, messageId: Block, accountBalanceString: string);

  calculateRunningHash(previousConfirmedTransaction: any): Block;

  calculateRunningHash(): Block;

  id: number;

  gradidoTransaction: any;

  confirmedAt: TimestampSeconds;

  versionNumber: string;

  runningHash: Block;

  messageId: Block;

  accountBalance: GradidoUnit;
}

export  class SecretKeyCryptography {

  constructor();

  constructor(opslimit: number, memlimit: number, algo: number);

  getKeyHashed(): number;

  equal(b: SecretKeyCryptography): boolean;

  isTheSame(b: SecretKeyCryptography): boolean;

  equal(hash: any): boolean;

  hasKey(): boolean;

  createKey(salt_parameter: string, passwd: string): void;

  encrypt(message: Block): Block;

  decrypt(encryptedMessage: Block): Block;
}

export  class TransactionBodyBuilder {

  constructor();

  reset(): void;

  build(): TransactionBody;

  setDeferredTransfer(senderPubkey: Block, amountGddCent: string, communityId: string, recipientPubkey: Block, timeout: Date): TransactionBodyBuilder;

  setCommunityFriendsUpdate(colorFusion: boolean): TransactionBodyBuilder;

  setRegisterAddress(userPubkey: Block, type: AddressType, nameHash: Block, accountPubkey: Block): TransactionBodyBuilder;

  setRegisterAddress(userPubkey: Block, type: AddressType, nameHash: Block): TransactionBodyBuilder;

  setRegisterAddress(userPubkey: Block, type: AddressType): TransactionBodyBuilder;

  setTransactionCreation(recipientPubkey: Block, amountGddCent: string, targetDate: Date): TransactionBodyBuilder;

  setTransactionTransfer(senderPubkey: Block, amountGddCent: string, communityId: string, recipientPubkey: Block): TransactionBodyBuilder;

  setCommunityRoot(pubkey: Block, gmwPubkey: Block, aufPubkey: Block): TransactionBodyBuilder;

  setCreatedAt(createdAt: Date): TransactionBodyBuilder;

  setMemo(memo: string): TransactionBodyBuilder;

  setCrossGroupType(type: CrossGroupType): TransactionBodyBuilder;

  setOtherGroup(otherGroup: string): TransactionBodyBuilder;
}

export  class GradidoTransactionBuilder {

  constructor();

  reset(): void;

  build(): GradidoTransaction;

  setTransactionBody(body: TransactionBody): GradidoTransactionBuilder;

  addSignaturePair(publicKey: Block, signature: Block): GradidoTransactionBuilder;

  sign(keyPair: any): GradidoTransactionBuilder;

  setParentMessageId(paringMessageId: Block): GradidoTransactionBuilder;
}


