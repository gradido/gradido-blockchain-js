/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG JSE (https://www.swig.org).
 * Version 5.0.3
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

#include "swig/gradido-blockchain-js.h"

/* -----------------------------------------------------------------------------
 * swigrun_body.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(const swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  Choose the last
     name. It should be the most specific; a fully resolved name
     but not necessarily with default template parameters expanded. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* ---------------------------------------------------------------------------
 * SWIG Node-API runtime : code
 * ---------------------------------------------------------------------------*/

#define SWIG_NAPI_PACKEDOBJECT 0x8000

SWIGRUNTIME Napi::Error SWIG_NAPI_NewError(Napi::Env env, int type, const char *msg) {
  switch(type) {
    default:
    case SWIG_IOError:
    case SWIG_MemoryError:
    case SWIG_SystemError:
    case SWIG_RuntimeError:
    case SWIG_DivisionByZero:
    case SWIG_SyntaxError:
      return Napi::Error::New(env, msg);
    case SWIG_OverflowError:
    case SWIG_IndexError:
      return Napi::RangeError::New(env, msg);
    case SWIG_ValueError:
    case SWIG_TypeError:
      return Napi::TypeError::New(env, msg);
  }
}

SWIGRUNTIME inline Napi::Error SWIG_NAPI_NewError(Napi::Env env, const char *msg) {
  return SWIG_NAPI_NewError(env, SWIG_RuntimeError, msg);
}

SWIGRUNTIME inline Napi::Error SWIG_NAPI_NewError(Napi::Env env, Napi::Value obj, const char *msg, swig_type_info *info) {
  return Napi::Error(env, obj);
}

#ifdef NAPI_CPP_EXCEPTIONS

SWIGRUNTIME void SWIG_NAPI_Raise(Napi::Env env, const char *msg) {
  SWIG_NAPI_ASSERT_NOTNULL_ENV;
  throw Napi::Error::New(env, msg);
}

SWIGRUNTIME void SWIG_NAPI_Raise(Napi::Env env, int type, const char *msg) {
  SWIG_NAPI_ASSERT_NOTNULL_ENV;
  switch(type) {
    default:
    case SWIG_IOError:
    case SWIG_MemoryError:
    case SWIG_SystemError:
    case SWIG_RuntimeError:
    case SWIG_DivisionByZero:
    case SWIG_SyntaxError:
      throw Napi::Error::New(env, msg);
    case SWIG_OverflowError:
    case SWIG_IndexError:
      throw Napi::RangeError::New(env, msg);
    case SWIG_ValueError:
    case SWIG_TypeError:
      throw Napi::TypeError::New(env, msg);
  }
}

SWIGRUNTIME void SWIG_NAPI_Raise(Napi::Env env, Napi::Value obj,
        const char *msg, swig_type_info *info) {
  SWIG_NAPI_ASSERT_NOTNULL_ENV;
  throw Napi::Error(env, obj);
}

#else // NAPI_CPP_EXCEPTIONS

SWIGRUNTIME inline void SWIG_NAPI_Raise(Napi::Env env, int type, const char *msg) {
  SWIG_NAPI_NewError(env, type, msg).ThrowAsJavaScriptException();
}

SWIGRUNTIME inline void SWIG_NAPI_Raise(Napi::Env env, const char *msg) {
  SWIG_NAPI_Raise(env, SWIG_RuntimeError, msg);
}

SWIGRUNTIME inline void SWIG_NAPI_Raise(Napi::Env env, Napi::Value obj,
        const char *msg, swig_type_info *info) {
  SWIG_NAPI_NewError(env, obj, msg, info).ThrowAsJavaScriptException();
}

#endif // NAPI_CPP_EXCEPTIONS

void JS_veto_set_variable(const Napi::CallbackInfo &info) {
  SWIG_NAPI_Raise(info.Env(), "Tried to write read-only variable.");
}

SWIG_Guard::SWIG_Guard(SWIG_Locks_List &_list) : list(_list), locked(false) {}
SWIG_Guard::~SWIG_Guard() {
  if (locked) {
    for (auto const &lock : list) {
      lock.second.second();
    }
  }
}


void SWIG_NAPI_ObjectWrap_inst::GetMembers(
        Napi::Env env,
        std::map<std::string, SWIG_NAPI_ObjectWrap_templ::PropertyDescriptor> &members,
        std::map<std::string, SWIG_NAPI_ObjectWrap_templ::PropertyDescriptor> &
) {
  members.erase("toString");
  members.insert({"toString", SWIG_NAPI_ObjectWrap_templ::InstanceMethod("toString", &SWIG_NAPI_ObjectWrap_templ::ToString)});
}

Napi::Function SWIG_NAPI_ObjectWrap_inst::GetClass(Napi::Env env) {
  return Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::DefineClass(env, "SwigObject", {});
}

SWIG_NAPI_ObjectWrap_inst::~SWIG_NAPI_ObjectWrap_inst() {
  if (this->owned) {
    if (this->info) {
      fprintf(stderr, "Warning, SWIG cannot delete an object of type %s, "
                      "it does not have a destructor. This is a memory leak.\n",
                      this->info->name);
    } else {
      fprintf(stderr, "Warning, SWIG must delete an object and does not know "
                      "its type. This is a memory leak\n");
    }
  }
}

Napi::Function SWIG_NAPI_PackedObjectWrap_inst::GetClass(Napi::Env env) {
  return Napi::ObjectWrap<SWIG_NAPI_PackedObjectWrap_inst>::DefineClass(env, "SwigPackedObject", {});
}

SWIG_NAPI_PackedObjectWrap_inst::~SWIG_NAPI_PackedObjectWrap_inst() {
  this->SWIG_Finalize();
  if (this->owned) {
    delete[] static_cast<uint8_t *>(this->self);
    this->self = SWIG_NULLPTR;
    this->owned = false;
  }
}

SWIGRUNTIME bool SWIG_NAPI_IsWrappedObject(Napi::Env env, Napi::Object v) {
  SWIG_NAPI_ASSERT_NOTNULL_ENV;
  // Check if this is a SWIG wrapper
  Napi::FunctionReference *ctor = env.GetInstanceData<EnvInstanceData>()->SWIG_NAPI_ObjectWrapCtor;
  bool instanceOf;
  NAPI_CHECK_RESULT(v.InstanceOf(ctor->Value()), instanceOf);
  return instanceOf;
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
  return false;
#endif
}

SWIGRUNTIME int SWIG_NAPI_ConvertInstancePtr(Napi::Object objRef, void **ptr, swig_type_info *info, int flags) {
  SWIG_NAPI_ObjectWrap_inst *ow;
  Napi::Env env = objRef.Env();
  if(!objRef.IsObject()) return SWIG_ERROR;

  if (!SWIG_NAPI_IsWrappedObject(env, objRef)) {
    return SWIG_TypeError;
  }

  ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(objRef);

  // Now check if the SWIG type is compatible unless the types match exactly or the type is unknown
  if(info && ow->info != info && ow->info != SWIG_NULLPTR) {
    swig_cast_info *tc = SWIG_TypeCheckStruct(ow->info, info);
    if (!tc && ow->info->name) {
      tc = SWIG_TypeCheck(ow->info->name, info);
    }
    bool type_valid = tc != 0;
    if(!type_valid) {
      return SWIG_TypeError;
    }
    int newmemory = 0;
    *ptr = SWIG_TypeCast(tc, ow->self, &newmemory);
    assert(!newmemory); /* newmemory handling not yet implemented */
  } else {
    *ptr = ow->self;
  }

  if (((flags & SWIG_POINTER_RELEASE) == SWIG_POINTER_RELEASE) && (!ow->owned || ow->finalizer)) {
    return SWIG_ERROR_RELEASE_NOT_OWNED;
  } else {
    if (flags & SWIG_POINTER_DISOWN) {
      ow->owned = false;
    }
    if (flags & SWIG_POINTER_CLEAR) {
      ow->self = SWIG_NULLPTR;
    }
  }
  return SWIG_OK;
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
  return SWIG_ERROR;
#endif
}


SWIGRUNTIME int SWIG_NAPI_GetInstancePtr(Napi::Value valRef, void **ptr) {
  SWIG_NAPI_ObjectWrap_inst *ow;
  if(!valRef.IsObject()) {
    return SWIG_TypeError;
  }
  Napi::Object objRef;
  NAPI_CHECK_RESULT(valRef.ToObject(), objRef);
  ow = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(objRef);

  if(ow->self == SWIG_NULLPTR) {
    return SWIG_ERROR;
  }

  *ptr = ow->self;
  return SWIG_OK;
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
  return SWIG_ERROR;
#endif
}


SWIGRUNTIME int SWIG_NAPI_ConvertPtr(Napi::Value valRef, void **ptr, swig_type_info *info, int flags) {
  // special case: JavaScript null => C NULL pointer
  if (valRef.IsNull()) {
    if ((flags & SWIG_POINTER_NO_NULL) == SWIG_POINTER_NO_NULL) {
      return SWIG_NullReferenceError;
    }
    *ptr=0;
    return SWIG_OK;
  }

  if (!valRef.IsObject()) {
    return SWIG_TypeError;
  }

  Napi::Object objRef;
  NAPI_CHECK_RESULT(valRef.ToObject(), objRef);
  return SWIG_NAPI_ConvertInstancePtr(objRef, ptr, info, flags);
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
  return SWIG_ERROR;
#endif
}

SWIGRUNTIME Napi::Value SWIG_NAPI_NewPointerObj(Napi::Env env, void *ptr, swig_type_info *info, int flags) {
  SWIG_NAPI_ASSERT_NOTNULL_ENV;
  Napi::External<void> native;
  Napi::FunctionReference *ctor;

  if (ptr == SWIG_NULLPTR) {
    return env.Null();
  }
  native = Napi::External<void>::New(env, ptr);

  size_t *idx = info != SWIG_NULLPTR ?
        reinterpret_cast<SWIG_NAPI_ClientData *>(info->clientdata) :
        SWIG_NULLPTR;
  if ((flags & SWIG_NAPI_PACKEDOBJECT) == SWIG_NAPI_PACKEDOBJECT) {
    ctor = env.GetInstanceData<EnvInstanceData>()->SWIG_NAPI_PackedObjectWrapCtor;
  } else if (idx == SWIG_NULLPTR) {
    // This type does not have a dedicated wrapper
    ctor = env.GetInstanceData<EnvInstanceData>()->SWIG_NAPI_ObjectWrapCtor;
  } else {
    ctor = env.GetInstanceData<EnvInstanceData>()->ctor[*idx];
  }

  Napi::Value wrapped;
  NAPI_CHECK_RESULT(ctor->New({native}), wrapped);

  // Preserve the type even if using the generic wrapper
  if (idx == SWIG_NULLPTR && info != SWIG_NULLPTR) {
    Napi::Object obj;
    NAPI_CHECK_RESULT(wrapped.ToObject(), obj);
    Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj)->info = info;
  }

  if ((flags & SWIG_POINTER_OWN) == SWIG_POINTER_OWN) {
    Napi::Object obj;
    NAPI_CHECK_RESULT(wrapped.ToObject(), obj);
    Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj)->owned = true;
  }

  return wrapped;
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
  return Napi::Value();
#endif
}

SWIGRUNTIME int SWIG_NAPI_SetFinalizer(Napi::Env env, Napi::Value val, SWIG_NAPI_Finalizer *finalizer) {
  Napi::Object obj;
  SWIG_NAPI_ObjectWrap_inst *unwrapped;
  NAPI_CHECK_RESULT(val.ToObject(), obj);
  if (!SWIG_NAPI_IsWrappedObject(env, obj)) {
    return SWIG_TypeError;
  }
  unwrapped = Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj);
  unwrapped->finalizer = finalizer;
  return SWIG_OK;
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
  return SWIG_ERROR;
#endif
}

SWIGRUNTIME void SWIG_NAPI_SetInstanceData(Napi::Env env, void *module_instance_data) {
  env.GetInstanceData<EnvInstanceData>()->module_instance_data = module_instance_data;
}
SWIGRUNTIME void *SWIG_NAPI_GetInstanceData(Napi::Env env) {
  return env.GetInstanceData<EnvInstanceData>()->module_instance_data;
}

SWIGRUNTIME Napi::Value _SWIG_NAPI_wrap_equals(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  void *arg1 = (void *) 0 ;
  void *arg2 = (void *) 0 ;
  bool result;
  int res1;
  int res2;

  if(info.Length() != 1) SWIG_Error(SWIG_ERROR, "Illegal number of arguments for equals.");

  res1 = SWIG_GetInstancePtr(info.This(), &arg1);
  if (!SWIG_IsOK(res1)) {
    SWIG_Error(SWIG_ERROR, "Could not get pointer from 'this' object for equals.");
  }
  res2 = SWIG_GetInstancePtr(info[0], &arg2);
  if (!SWIG_IsOK(res2)) {
    SWIG_Error(SWIG_ArgError(res2), " in method '" "equals" "', argument " "1"" of type '" "void *""'");
  }

  result = (bool)(arg1 == arg2);
  jsresult = Napi::Boolean::New(env, result);

  return jsresult;
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
  return Napi::Value();
#endif
}

SWIGRUNTIME Napi::Value _wrap_getCPtr(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  void *arg1 = (void *) 0 ;
  long result;
  int res1;

  res1 = SWIG_GetInstancePtr(info.This(), &arg1);
  if (!SWIG_IsOK(res1)) {
    SWIG_Error(SWIG_ArgError(res1), " in method '" "getCPtr" "', argument " "1"" of type '" "void *""'");
  }

  result = (long)arg1;
  jsresult = Napi::Number::New(env, result);

  return jsresult;
#ifndef NAPI_CPP_EXCEPTIONS
  goto fail;
fail:
  return Napi::Value();
#endif
}

/* ---------------------------------------------------------------------------
 * PackedData object
 * (objects visible to JS that do not have a dedicated wrapper but must preserve type)
 * ---------------------------------------------------------------------------*/

SWIGRUNTIME
Napi::Value SWIG_NAPI_NewPackedObj(Napi::Env env, void *data, size_t size, swig_type_info *type) {
  void *data_copy = new uint8_t[size];
  memcpy(data_copy, data, size);
  Napi::Value val = SWIG_NAPI_NewPointerObj(env, data_copy, type, SWIG_POINTER_OWN | SWIG_NAPI_PACKEDOBJECT);
  Napi::Object obj;
  if (val.IsEmpty()) goto fail;

  NAPI_CHECK_RESULT(val.ToObject(), obj);
  Napi::ObjectWrap<SWIG_NAPI_ObjectWrap_inst>::Unwrap(obj)->size = size;

fail:
  return val;
}

SWIGRUNTIME
int SWIG_NAPI_ConvertPacked(Napi::Value valRef, void *ptr, size_t size, swig_type_info *type) {
  void *tmp;
  if (!SWIG_IsOK(SWIG_NAPI_ConvertPtr(valRef, &tmp, type, 0))) {
    return SWIG_ERROR;
  }
  memcpy(ptr, tmp, size);
  return SWIG_OK;
}


/* ---------------------------------------------------------------------------
 * Support for IN/OUTPUT typemaps (see Lib/typemaps/inoutlist.swg)
 *
 * ---------------------------------------------------------------------------*/

SWIGRUNTIME
Napi::Value SWIG_NAPI_AppendOutput(Napi::Env env, Napi::Value result, Napi::Value obj) {
  if (result.IsUndefined()) {
    result = Napi::Array::New(env);
  } else if (!result.IsArray()) {
    Napi::Array tmparr = Napi::Array::New(env);
    tmparr.Set(static_cast<uint32_t>(0), result);
    result = tmparr;
  }

  Napi::Array arr = result.As<Napi::Array>();
  arr.Set(arr.Length(), obj);
  return arr;
}


SWIGINTERN
Napi::Value SWIG_From_bool(Napi::Env env, bool val)
{
  return Napi::Boolean::New(env, val);
}


// js_global_getter
Napi::Value exports_AddressType_NONE_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::AddressType::NONE));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_AddressType_COMMUNITY_HUMAN_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::AddressType::COMMUNITY_HUMAN));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_AddressType_COMMUNITY_GMW_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::AddressType::COMMUNITY_GMW));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_AddressType_COMMUNITY_AUF_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::AddressType::COMMUNITY_AUF));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_AddressType_COMMUNITY_PROJECT_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::AddressType::COMMUNITY_PROJECT));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_AddressType_SUBACCOUNT_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::AddressType::SUBACCOUNT));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_AddressType_CRYPTO_ACCOUNT_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::AddressType::CRYPTO_ACCOUNT));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_CrossGroupType_LOCAL_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::CrossGroupType::LOCAL));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_CrossGroupType_INBOUND_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::CrossGroupType::INBOUND));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_CrossGroupType_OUTBOUND_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::CrossGroupType::OUTBOUND));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_CrossGroupType_CROSS_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::CrossGroupType::CROSS));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_TransactionType_NONE_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::TransactionType::NONE));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_TransactionType_CREATION_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::TransactionType::CREATION));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_TransactionType_TRANSFER_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::TransactionType::TRANSFER));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_TransactionType_COMMUNITY_FRIENDS_UPDATE_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::TransactionType::COMMUNITY_FRIENDS_UPDATE));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_TransactionType_REGISTER_ADDRESS_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::TransactionType::REGISTER_ADDRESS));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_TransactionType_DEFERRED_TRANSFER_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::TransactionType::DEFERRED_TRANSFER));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_TransactionType_COMMUNITY_ROOT_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::data::TransactionType::COMMUNITY_ROOT));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


SWIGINTERN
int SWIG_AsVal_int (Napi::Value valRef, int* val)
{
  if (!valRef.IsNumber()) {
    return SWIG_TypeError;
  }
  if (val) {
    Napi::Number num;
    NAPI_CHECK_RESULT(valRef.ToNumber(), num);
    *val = static_cast<int>(num.Int32Value());
  }

  return SWIG_OK;
  goto fail;
fail:
  return SWIG_ERROR;
}


SWIGINTERN
int SWIG_AsVal_unsigned_SS_long (Napi::Value obj, unsigned long *val)
{
  if(!obj.IsNumber()) {
    return SWIG_TypeError;
  }
  if (val) {
    Napi::Number num;
    NAPI_CHECK_RESULT(obj.ToNumber(), num);
    if (num.Int64Value() < 0) {
      return SWIG_TypeError;
    }
    *val = static_cast<unsigned long>(num.Int64Value());
  }
  return SWIG_OK;
  goto fail;
fail:
  return SWIG_ERROR;
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN
int SWIG_AsVal_unsigned_SS_long_SS_long (Napi::Value obj, unsigned long long *val)
{
  if(!obj.IsNumber()) {
    return SWIG_TypeError;
  }
  if (obj.ToNumber().Int64Value() < 0) {
    return SWIG_TypeError;
  }
  if (val) {
    Napi::Number num;
    NAPI_CHECK_RESULT(obj.ToNumber(), num);
    *val = static_cast<unsigned long long>(num.Int64Value());
  }
  return SWIG_OK;
  goto fail;
fail:
  return SWIG_ERROR;
}
#endif


SWIGINTERN int
SWIG_AsCharPtrAndSize(Napi::Value valRef, char** cptr, size_t* psize, int *alloc)
{
  if(valRef.IsString()) {
    Napi::String js_str;
    NAPI_CHECK_RESULT(valRef.ToString(), js_str);

    std::string str = js_str.Utf8Value();
    size_t len = str.size() + 1;
    char* cstr = (char*) (new char[len]());
    memcpy(cstr, str.data(), len);
    
    if(alloc) *alloc = SWIG_NEWOBJ;
    if(psize) *psize = len;
    if(cptr) *cptr = cstr;
    
    return SWIG_OK;
  } else if (valRef.IsNull()) {
    if (cptr) *cptr = 0;
    return SWIG_OK;
  } else {
    if(valRef.IsObject()) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      Napi::Object obj;
      NAPI_CHECK_RESULT(valRef.ToObject(), obj);
      // try if the object is a wrapped char[]
      if (pchar_descriptor) {
        void* vptr = 0;
        if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
          if (cptr) *cptr = (char *) vptr;
          if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
          if (alloc) *alloc = SWIG_OLDOBJ;
          return SWIG_OK;
        }
      }
    }
  }
  goto fail;
fail:
  return SWIG_TypeError;
}


SWIGCLINKAGE int
SWIG_AsPtr_std_string (Napi::Value obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}


// js_global_getter
Napi::Value exports_MnemonicType_GRADIDO_BOOK_GERMAN_RANDOM_ORDER_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(MnemonicType::GRADIDO_BOOK_GERMAN_RANDOM_ORDER));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_MnemonicType_GRADIDO_BOOK_GERMAN_RANDOM_ORDER_FIXED_CASES_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(MnemonicType::GRADIDO_BOOK_GERMAN_RANDOM_ORDER_FIXED_CASES));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_MnemonicType_BIP0039_SORTED_ORDER_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(MnemonicType::BIP0039_SORTED_ORDER));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_MnemonicType_MAX_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(MnemonicType::MAX));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_Ed25519DerivationType_SOFT_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(Ed25519DerivationType::SOFT));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_Ed25519DerivationType_HARD_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(Ed25519DerivationType::HARD));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_ED25519_CHAIN_CODE_SIZE_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(32));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


SWIGINTERN
int SWIG_AsVal_unsigned_SS_int (Napi::Value valRef, unsigned int* val)
{
  if (!valRef.IsNumber()) {
    return SWIG_TypeError;
  }
  if (val) {
    Napi::Number num;
    NAPI_CHECK_RESULT(valRef.ToNumber(), num);
    if (num.Int64Value() < 0) {
      return SWIG_TypeError;
    }
    *val = static_cast<unsigned int>(num.Uint32Value());
  }

  return SWIG_OK;
  goto fail;
fail:
  return SWIG_ERROR;
}


SWIGINTERN
int SWIG_AsVal_double (Napi::Value obj, double *val)
{
  if(!obj.IsNumber()) {
    return SWIG_TypeError;
  }

  if(val) {
    Napi::Number num;
    NAPI_CHECK_RESULT(obj.ToNumber(), num);
    *val = static_cast<double>(num.DoubleValue());
  }

  return SWIG_OK;
  goto fail;
fail:
  return SWIG_ERROR;
}


SWIGINTERN
int SWIG_AsVal_long (Napi::Value obj, long* val)
{
  if (!obj.IsNumber()) {
    return SWIG_TypeError;
  }
  if (val) {
    Napi::Number num;
    NAPI_CHECK_RESULT(obj.ToNumber(), num);
    *val = static_cast<long>(num.Int64Value());
  }

  return SWIG_OK;
  goto fail;
fail:
  return SWIG_ERROR;
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN
int SWIG_AsVal_long_SS_long (Napi::Value obj, long long* val)
{
  if(!obj.IsNumber()) {
    return SWIG_TypeError;
  }

  if (val) {
    Napi::Number num;
    NAPI_CHECK_RESULT(obj.ToNumber(), num);
    *val = static_cast<long long>(num.Int64Value());
  }
  return SWIG_OK;
  goto fail;
fail:
  return SWIG_ERROR;
}
#endif


SWIGINTERN
int SWIG_AsVal_bool (Napi::Value obj, bool *val)
{
  if(!obj.IsBoolean()) {
    return SWIG_TypeError;
  }

  Napi::Boolean b;
  NAPI_CHECK_RESULT(obj.ToBoolean(), b);
  if (val) *val = b.Value();
  return SWIG_OK;
  goto fail;
fail:
  return SWIG_ERROR;
}


// js_global_getter
Napi::Value exports_DeserializeType_UNKNOWN_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::deserialize::Type::UNKNOWN));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_DeserializeType_TRANSACTION_BODY_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::deserialize::Type::TRANSACTION_BODY));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_DeserializeType_GRADIDO_TRANSACTION_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::deserialize::Type::GRADIDO_TRANSACTION));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_DeserializeType_CONFIRMED_TRANSACTION_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::deserialize::Type::CONFIRMED_TRANSACTION));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_DeserializeType_MAX_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::deserialize::Type::MAX));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_FilterResult_USE_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::blockchain::FilterResult::USE));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_FilterResult_DISMISS_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::blockchain::FilterResult::DISMISS));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_FilterResult_STOP_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::blockchain::FilterResult::STOP));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_SearchDirection_ASC_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::blockchain::SearchDirection::ASC));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_SearchDirection_DESC_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::blockchain::SearchDirection::DESC));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_BodyBytesType_BASE64_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::toJson::BodyBytesType::BASE64));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_BodyBytesType_HEX_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::toJson::BodyBytesType::HEX));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_BodyBytesType_JSON_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::toJson::BodyBytesType::JSON));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_ValidateType_SINGLE_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::validate::Type::SINGLE));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_ValidateType_PREVIOUS_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::validate::Type::PREVIOUS));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_ValidateType_MONTH_RANGE_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::validate::Type::MONTH_RANGE));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_ValidateType_PAIRED_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::validate::Type::PAIRED));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_ValidateType_ACCOUNT_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::validate::Type::ACCOUNT));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_ValidateType_CONNECTED_GROUP_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::validate::Type::CONNECTED_GROUP));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}


// js_global_getter
Napi::Value exports_ValidateType_CONNECTED_BLOCKCHAIN_get(const Napi::CallbackInfo &info) {
  Napi::Env env = info.Env();
  Napi::Value jsresult;
  
#ifdef NAPI_CPP_EXCEPTIONS
  try {
#endif
    
    
    
    jsresult = SWIG_From_int  SWIG_NAPI_FROM_CALL_ARGS(static_cast< int >(gradido::interaction::validate::Type::CONNECTED_BLOCKCHAIN));
    
    
    
    return jsresult;
#ifdef NAPI_CPP_EXCEPTIONS
  } catch (...) {
    std::rethrow_exception(std::current_exception());
  }
#else
  goto fail;
fail:
  
  return Napi::Value();
#endif
}




EnvInstanceData::EnvInstanceData(Napi::Env env, swig_module_info *swig_module) :
  env(env), SWIG_NAPI_ObjectWrapCtor(SWIG_NULLPTR), SWIG_NAPI_PackedObjectWrapCtor(SWIG_NULLPTR),
  ctor(SWIG_NULLPTR), swig_module(swig_module), module_instance_data(SWIG_NULLPTR) {
  ctor = new Napi::FunctionReference*[swig_module->size + 1];
  for (size_t i = 0; i <= swig_module->size; i++) {
    ctor[i] = SWIG_NULLPTR;
  }
}

EnvInstanceData::~EnvInstanceData() {
  for (size_t i = 0; i <= swig_module->size; i++) {
    if (ctor[i] != SWIG_NULLPTR)
      delete ctor[i];
    ctor[i] = SWIG_NULLPTR;
  }
  delete [] ctor;
  delete SWIG_NAPI_ObjectWrapCtor;
  delete SWIG_NAPI_PackedObjectWrapCtor;
}

SWIGRUNTIME void
SWIG_NAPI_SetModule(Napi::Env env, swig_module_info *swig_module) {
  auto data = new EnvInstanceData(env, swig_module);
  env.SetInstanceData(data);
}

SWIGRUNTIME swig_module_info *
SWIG_NAPI_GetModule(Napi::Env env) {
  auto data = env.GetInstanceData<EnvInstanceData>();
  if (data == SWIG_NULLPTR) return SWIG_NULLPTR;
  return data->swig_module;
}

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif

#ifndef SWIG_INIT_CLIENT_DATA_TYPE
#define SWIG_INIT_CLIENT_DATA_TYPE void *
#endif

SWIGRUNTIME void
SWIG_InitializeModule(SWIG_INIT_CLIENT_DATA_TYPE clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpreters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;

#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {

      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif


Napi::Object Init(Napi::Env env, Napi::Object exports) {
  SWIG_InitializeModule(env);


CryptoConfig::loadMnemonicWordLists();


  /* initialize the base SWIG object class */
  Napi::Function SWIG_NAPI_ObjectWrap_ctor = SWIG_NAPI_ObjectWrap_inst::GetClass(env);
  Napi::FunctionReference *SWIG_NAPI_ObjectWrap_ctor_ref = new Napi::FunctionReference();
  *SWIG_NAPI_ObjectWrap_ctor_ref = Napi::Persistent(SWIG_NAPI_ObjectWrap_ctor);
  env.GetInstanceData<EnvInstanceData>()->SWIG_NAPI_ObjectWrapCtor = SWIG_NAPI_ObjectWrap_ctor_ref;

  /* initialize the SWIG packed object class */
  Napi::Function SWIG_NAPI_PackedObjectWrap_ctor = SWIG_NAPI_PackedObjectWrap_inst::GetClass(env);
  Napi::FunctionReference *SWIG_NAPI_PackedObjectWrap_ctor_ref = new Napi::FunctionReference();
  *SWIG_NAPI_PackedObjectWrap_ctor_ref = Napi::Persistent(SWIG_NAPI_PackedObjectWrap_ctor);
  env.GetInstanceData<EnvInstanceData>()->SWIG_NAPI_PackedObjectWrapCtor = SWIG_NAPI_PackedObjectWrap_ctor_ref;

  /* create objects for namespaces */
  

  /* register classes */
  /* Class: TimepointInterval (_exports_TimepointInterval) */
// jsnapi_registerclass
Napi::Function _exports_TimepointInterval_ctor = _exports_TimepointInterval_inst::GetClass(env);
exports.Set("TimepointInterval", _exports_TimepointInterval_ctor);
if (SWIGTYPE_p_TimepointInterval->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_TimepointInterval->clientdata = new size_t(0);
}
Napi::FunctionReference *_exports_TimepointInterval_ctor_ref = new Napi::FunctionReference();
*_exports_TimepointInterval_ctor_ref = Napi::Persistent(_exports_TimepointInterval_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[0] = _exports_TimepointInterval_ctor_ref;
/* Class: Profiler (_exports_Profiler) */
// jsnapi_registerclass
Napi::Function _exports_Profiler_ctor = _exports_Profiler_inst::GetClass(env);
exports.Set("Profiler", _exports_Profiler_ctor);
if (SWIGTYPE_p_Profiler->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_Profiler->clientdata = new size_t(1);
}
Napi::FunctionReference *_exports_Profiler_ctor_ref = new Napi::FunctionReference();
*_exports_Profiler_ctor_ref = Napi::Persistent(_exports_Profiler_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[1] = _exports_Profiler_ctor_ref;
/* Class: MemoryBlocks (_exports_MemoryBlocks) */
// jsnapi_registerclass
Napi::Function _exports_MemoryBlocks_ctor = _exports_MemoryBlocks_inst::GetClass(env);
exports.Set("MemoryBlocks", _exports_MemoryBlocks_ctor);
if (SWIGTYPE_p_std__vectorT_std__shared_ptrT_memory__Block_t_t->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_std__vectorT_std__shared_ptrT_memory__Block_t_t->clientdata = new size_t(2);
}
Napi::FunctionReference *_exports_MemoryBlocks_ctor_ref = new Napi::FunctionReference();
*_exports_MemoryBlocks_ctor_ref = Napi::Persistent(_exports_MemoryBlocks_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[2] = _exports_MemoryBlocks_ctor_ref;
/* Class: MemoryBlock (_exports_MemoryBlock) */
// jsnapi_registerclass
Napi::Function _exports_MemoryBlock_ctor = _exports_MemoryBlock_inst::GetClass(env);
exports.Set("MemoryBlock", _exports_MemoryBlock_ctor);
if (SWIGTYPE_p_memory__Block->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_memory__Block->clientdata = new size_t(3);
}
Napi::FunctionReference *_exports_MemoryBlock_ctor_ref = new Napi::FunctionReference();
*_exports_MemoryBlock_ctor_ref = Napi::Persistent(_exports_MemoryBlock_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[3] = _exports_MemoryBlock_ctor_ref;
/* Class: Passphrase (_exports_Passphrase) */
// jsnapi_registerclass
Napi::Function _exports_Passphrase_ctor = _exports_Passphrase_inst::GetClass(env);
exports.Set("Passphrase", _exports_Passphrase_ctor);
if (SWIGTYPE_p_Passphrase->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_Passphrase->clientdata = new size_t(4);
}
Napi::FunctionReference *_exports_Passphrase_ctor_ref = new Napi::FunctionReference();
*_exports_Passphrase_ctor_ref = Napi::Persistent(_exports_Passphrase_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[4] = _exports_Passphrase_ctor_ref;
/* Class: SecretKeyCryptography (_exports_SecretKeyCryptography) */
// jsnapi_registerclass
Napi::Function _exports_SecretKeyCryptography_ctor = _exports_SecretKeyCryptography_inst::GetClass(env);
exports.Set("SecretKeyCryptography", _exports_SecretKeyCryptography_ctor);
if (SWIGTYPE_p_SecretKeyCryptography->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_SecretKeyCryptography->clientdata = new size_t(5);
}
Napi::FunctionReference *_exports_SecretKeyCryptography_ctor_ref = new Napi::FunctionReference();
*_exports_SecretKeyCryptography_ctor_ref = Napi::Persistent(_exports_SecretKeyCryptography_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[5] = _exports_SecretKeyCryptography_ctor_ref;
/* Class: KeyPairEd25519 (_exports_KeyPairEd25519) */
// jsnapi_registerclass
Napi::Function _exports_KeyPairEd25519_ctor = _exports_KeyPairEd25519_inst::GetClass(env);
exports.Set("KeyPairEd25519", _exports_KeyPairEd25519_ctor);
if (SWIGTYPE_p_KeyPairEd25519->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_KeyPairEd25519->clientdata = new size_t(6);
}
Napi::FunctionReference *_exports_KeyPairEd25519_ctor_ref = new Napi::FunctionReference();
*_exports_KeyPairEd25519_ctor_ref = Napi::Persistent(_exports_KeyPairEd25519_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[6] = _exports_KeyPairEd25519_ctor_ref;
/* Class: KeyPairEd25519Ex (_exports_KeyPairEd25519Ex) */
// jsnapi_registerclass
Napi::Function _exports_KeyPairEd25519Ex_ctor = _exports_KeyPairEd25519Ex_inst::GetClass(env);
exports.Set("KeyPairEd25519Ex", _exports_KeyPairEd25519Ex_ctor);
if (SWIGTYPE_p_KeyPairEd25519Ex->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_KeyPairEd25519Ex->clientdata = new size_t(7);
}
Napi::FunctionReference *_exports_KeyPairEd25519Ex_ctor_ref = new Napi::FunctionReference();
*_exports_KeyPairEd25519Ex_ctor_ref = Napi::Persistent(_exports_KeyPairEd25519Ex_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[7] = _exports_KeyPairEd25519Ex_ctor_ref;
/* Class: AuthenticatedEncryption (_exports_AuthenticatedEncryption) */
// jsnapi_registerclass
Napi::Function _exports_AuthenticatedEncryption_ctor = _exports_AuthenticatedEncryption_inst::GetClass(env);
exports.Set("AuthenticatedEncryption", _exports_AuthenticatedEncryption_ctor);
if (SWIGTYPE_p_AuthenticatedEncryption->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_AuthenticatedEncryption->clientdata = new size_t(8);
}
Napi::FunctionReference *_exports_AuthenticatedEncryption_ctor_ref = new Napi::FunctionReference();
*_exports_AuthenticatedEncryption_ctor_ref = Napi::Persistent(_exports_AuthenticatedEncryption_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[8] = _exports_AuthenticatedEncryption_ctor_ref;
/* Class: GradidoUnit (_exports_GradidoUnit) */
// jsnapi_registerclass
Napi::Function _exports_GradidoUnit_ctor = _exports_GradidoUnit_inst::GetClass(env);
exports.Set("GradidoUnit", _exports_GradidoUnit_ctor);
if (SWIGTYPE_p_GradidoUnit->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_GradidoUnit->clientdata = new size_t(9);
}
Napi::FunctionReference *_exports_GradidoUnit_ctor_ref = new Napi::FunctionReference();
*_exports_GradidoUnit_ctor_ref = Napi::Persistent(_exports_GradidoUnit_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[9] = _exports_GradidoUnit_ctor_ref;
/* Class: SignaturePairs (_exports_SignaturePairs) */
// jsnapi_registerclass
Napi::Function _exports_SignaturePairs_ctor = _exports_SignaturePairs_inst::GetClass(env);
exports.Set("SignaturePairs", _exports_SignaturePairs_ctor);
if (SWIGTYPE_p_std__vectorT_gradido__data__SignaturePair_t->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_std__vectorT_gradido__data__SignaturePair_t->clientdata = new size_t(10);
}
Napi::FunctionReference *_exports_SignaturePairs_ctor_ref = new Napi::FunctionReference();
*_exports_SignaturePairs_ctor_ref = Napi::Persistent(_exports_SignaturePairs_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[10] = _exports_SignaturePairs_ctor_ref;
/* Class: TransferAmount (_exports_TransferAmount) */
// jsnapi_registerclass
Napi::Function _exports_TransferAmount_ctor = _exports_TransferAmount_inst::GetClass(env);
exports.Set("TransferAmount", _exports_TransferAmount_ctor);
if (SWIGTYPE_p_gradido__data__TransferAmount->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__TransferAmount->clientdata = new size_t(11);
}
Napi::FunctionReference *_exports_TransferAmount_ctor_ref = new Napi::FunctionReference();
*_exports_TransferAmount_ctor_ref = Napi::Persistent(_exports_TransferAmount_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[11] = _exports_TransferAmount_ctor_ref;
/* Class: TimestampSeconds (_exports_TimestampSeconds) */
// jsnapi_registerclass
Napi::Function _exports_TimestampSeconds_ctor = _exports_TimestampSeconds_inst::GetClass(env);
exports.Set("TimestampSeconds", _exports_TimestampSeconds_ctor);
if (SWIGTYPE_p_gradido__data__TimestampSeconds->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__TimestampSeconds->clientdata = new size_t(12);
}
Napi::FunctionReference *_exports_TimestampSeconds_ctor_ref = new Napi::FunctionReference();
*_exports_TimestampSeconds_ctor_ref = Napi::Persistent(_exports_TimestampSeconds_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[12] = _exports_TimestampSeconds_ctor_ref;
/* Class: Timestamp (_exports_Timestamp) */
// jsnapi_registerclass
Napi::Function _exports_Timestamp_ctor = _exports_Timestamp_inst::GetClass(env);
exports.Set("Timestamp", _exports_Timestamp_ctor);
if (SWIGTYPE_p_gradido__data__Timestamp->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__Timestamp->clientdata = new size_t(13);
}
Napi::FunctionReference *_exports_Timestamp_ctor_ref = new Napi::FunctionReference();
*_exports_Timestamp_ctor_ref = Napi::Persistent(_exports_Timestamp_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[13] = _exports_Timestamp_ctor_ref;
/* Class: SignaturePair (_exports_SignaturePair) */
// jsnapi_registerclass
Napi::Function _exports_SignaturePair_ctor = _exports_SignaturePair_inst::GetClass(env);
exports.Set("SignaturePair", _exports_SignaturePair_ctor);
if (SWIGTYPE_p_gradido__data__SignaturePair->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__SignaturePair->clientdata = new size_t(14);
}
Napi::FunctionReference *_exports_SignaturePair_ctor_ref = new Napi::FunctionReference();
*_exports_SignaturePair_ctor_ref = Napi::Persistent(_exports_SignaturePair_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[14] = _exports_SignaturePair_ctor_ref;
/* Class: SignatureMap (_exports_SignatureMap) */
// jsnapi_registerclass
Napi::Function _exports_SignatureMap_ctor = _exports_SignatureMap_inst::GetClass(env);
exports.Set("SignatureMap", _exports_SignatureMap_ctor);
if (SWIGTYPE_p_gradido__data__SignatureMap->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__SignatureMap->clientdata = new size_t(15);
}
Napi::FunctionReference *_exports_SignatureMap_ctor_ref = new Napi::FunctionReference();
*_exports_SignatureMap_ctor_ref = Napi::Persistent(_exports_SignatureMap_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[15] = _exports_SignatureMap_ctor_ref;
/* Class: CommunityFriendsUpdate (_exports_CommunityFriendsUpdate) */
// jsnapi_registerclass
Napi::Function _exports_CommunityFriendsUpdate_ctor = _exports_CommunityFriendsUpdate_inst::GetClass(env);
exports.Set("CommunityFriendsUpdate", _exports_CommunityFriendsUpdate_ctor);
if (SWIGTYPE_p_gradido__data__CommunityFriendsUpdate->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__CommunityFriendsUpdate->clientdata = new size_t(16);
}
Napi::FunctionReference *_exports_CommunityFriendsUpdate_ctor_ref = new Napi::FunctionReference();
*_exports_CommunityFriendsUpdate_ctor_ref = Napi::Persistent(_exports_CommunityFriendsUpdate_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[16] = _exports_CommunityFriendsUpdate_ctor_ref;
/* Class: CommunityRoot (_exports_CommunityRoot) */
// jsnapi_registerclass
Napi::Function _exports_CommunityRoot_ctor = _exports_CommunityRoot_inst::GetClass(env);
exports.Set("CommunityRoot", _exports_CommunityRoot_ctor);
if (SWIGTYPE_p_gradido__data__CommunityRoot->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__CommunityRoot->clientdata = new size_t(17);
}
Napi::FunctionReference *_exports_CommunityRoot_ctor_ref = new Napi::FunctionReference();
*_exports_CommunityRoot_ctor_ref = Napi::Persistent(_exports_CommunityRoot_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[17] = _exports_CommunityRoot_ctor_ref;
/* Class: GradidoCreation (_exports_GradidoCreation) */
// jsnapi_registerclass
Napi::Function _exports_GradidoCreation_ctor = _exports_GradidoCreation_inst::GetClass(env);
exports.Set("GradidoCreation", _exports_GradidoCreation_ctor);
if (SWIGTYPE_p_gradido__data__GradidoCreation->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__GradidoCreation->clientdata = new size_t(18);
}
Napi::FunctionReference *_exports_GradidoCreation_ctor_ref = new Napi::FunctionReference();
*_exports_GradidoCreation_ctor_ref = Napi::Persistent(_exports_GradidoCreation_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[18] = _exports_GradidoCreation_ctor_ref;
/* Class: GradidoTransfer (_exports_GradidoTransfer) */
// jsnapi_registerclass
Napi::Function _exports_GradidoTransfer_ctor = _exports_GradidoTransfer_inst::GetClass(env);
exports.Set("GradidoTransfer", _exports_GradidoTransfer_ctor);
if (SWIGTYPE_p_gradido__data__GradidoTransfer->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__GradidoTransfer->clientdata = new size_t(19);
}
Napi::FunctionReference *_exports_GradidoTransfer_ctor_ref = new Napi::FunctionReference();
*_exports_GradidoTransfer_ctor_ref = Napi::Persistent(_exports_GradidoTransfer_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[19] = _exports_GradidoTransfer_ctor_ref;
/* Class: GradidoDeferredTransfer (_exports_GradidoDeferredTransfer) */
// jsnapi_registerclass
Napi::Function _exports_GradidoDeferredTransfer_ctor = _exports_GradidoDeferredTransfer_inst::GetClass(env);
exports.Set("GradidoDeferredTransfer", _exports_GradidoDeferredTransfer_ctor);
if (SWIGTYPE_p_gradido__data__GradidoDeferredTransfer->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__GradidoDeferredTransfer->clientdata = new size_t(20);
}
Napi::FunctionReference *_exports_GradidoDeferredTransfer_ctor_ref = new Napi::FunctionReference();
*_exports_GradidoDeferredTransfer_ctor_ref = Napi::Persistent(_exports_GradidoDeferredTransfer_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[20] = _exports_GradidoDeferredTransfer_ctor_ref;
/* Class: RegisterAddress (_exports_RegisterAddress) */
// jsnapi_registerclass
Napi::Function _exports_RegisterAddress_ctor = _exports_RegisterAddress_inst::GetClass(env);
exports.Set("RegisterAddress", _exports_RegisterAddress_ctor);
if (SWIGTYPE_p_gradido__data__RegisterAddress->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__RegisterAddress->clientdata = new size_t(21);
}
Napi::FunctionReference *_exports_RegisterAddress_ctor_ref = new Napi::FunctionReference();
*_exports_RegisterAddress_ctor_ref = Napi::Persistent(_exports_RegisterAddress_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[21] = _exports_RegisterAddress_ctor_ref;
/* Class: TransactionBody (_exports_TransactionBody) */
// jsnapi_registerclass
Napi::Function _exports_TransactionBody_ctor = _exports_TransactionBody_inst::GetClass(env);
exports.Set("TransactionBody", _exports_TransactionBody_ctor);
if (SWIGTYPE_p_gradido__data__TransactionBody->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__TransactionBody->clientdata = new size_t(22);
}
Napi::FunctionReference *_exports_TransactionBody_ctor_ref = new Napi::FunctionReference();
*_exports_TransactionBody_ctor_ref = Napi::Persistent(_exports_TransactionBody_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[22] = _exports_TransactionBody_ctor_ref;
/* Class: GradidoTransaction (_exports_GradidoTransaction) */
// jsnapi_registerclass
Napi::Function _exports_GradidoTransaction_ctor = _exports_GradidoTransaction_inst::GetClass(env);
exports.Set("GradidoTransaction", _exports_GradidoTransaction_ctor);
if (SWIGTYPE_p_gradido__data__GradidoTransaction->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__GradidoTransaction->clientdata = new size_t(23);
}
Napi::FunctionReference *_exports_GradidoTransaction_ctor_ref = new Napi::FunctionReference();
*_exports_GradidoTransaction_ctor_ref = Napi::Persistent(_exports_GradidoTransaction_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[23] = _exports_GradidoTransaction_ctor_ref;
/* Class: ConfirmedTransaction (_exports_ConfirmedTransaction) */
// jsnapi_registerclass
Napi::Function _exports_ConfirmedTransaction_ctor = _exports_ConfirmedTransaction_inst::GetClass(env);
exports.Set("ConfirmedTransaction", _exports_ConfirmedTransaction_ctor);
if (SWIGTYPE_p_gradido__data__ConfirmedTransaction->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__data__ConfirmedTransaction->clientdata = new size_t(24);
}
Napi::FunctionReference *_exports_ConfirmedTransaction_ctor_ref = new Napi::FunctionReference();
*_exports_ConfirmedTransaction_ctor_ref = Napi::Persistent(_exports_ConfirmedTransaction_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[24] = _exports_ConfirmedTransaction_ctor_ref;
/* Class: GradidoTransactionBuilder (_exports_GradidoTransactionBuilder) */
// jsnapi_registerclass
Napi::Function _exports_GradidoTransactionBuilder_ctor = _exports_GradidoTransactionBuilder_inst::GetClass(env);
exports.Set("GradidoTransactionBuilder", _exports_GradidoTransactionBuilder_ctor);
if (SWIGTYPE_p_gradido__GradidoTransactionBuilder->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__GradidoTransactionBuilder->clientdata = new size_t(25);
}
Napi::FunctionReference *_exports_GradidoTransactionBuilder_ctor_ref = new Napi::FunctionReference();
*_exports_GradidoTransactionBuilder_ctor_ref = Napi::Persistent(_exports_GradidoTransactionBuilder_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[25] = _exports_GradidoTransactionBuilder_ctor_ref;
/* Class: InteractionDeserialize (_exports_InteractionDeserialize) */
// jsnapi_registerclass
Napi::Function _exports_InteractionDeserialize_ctor = _exports_InteractionDeserialize_inst::GetClass(env);
exports.Set("InteractionDeserialize", _exports_InteractionDeserialize_ctor);
if (SWIGTYPE_p_gradido__interaction__deserialize__Context->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__interaction__deserialize__Context->clientdata = new size_t(26);
}
Napi::FunctionReference *_exports_InteractionDeserialize_ctor_ref = new Napi::FunctionReference();
*_exports_InteractionDeserialize_ctor_ref = Napi::Persistent(_exports_InteractionDeserialize_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[26] = _exports_InteractionDeserialize_ctor_ref;
/* Class: InteractionSerialize (_exports_InteractionSerialize) */
// jsnapi_registerclass
Napi::Function _exports_InteractionSerialize_ctor = _exports_InteractionSerialize_inst::GetClass(env);
exports.Set("InteractionSerialize", _exports_InteractionSerialize_ctor);
if (SWIGTYPE_p_gradido__interaction__serialize__Context->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__interaction__serialize__Context->clientdata = new size_t(27);
}
Napi::FunctionReference *_exports_InteractionSerialize_ctor_ref = new Napi::FunctionReference();
*_exports_InteractionSerialize_ctor_ref = Napi::Persistent(_exports_InteractionSerialize_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[27] = _exports_InteractionSerialize_ctor_ref;
/* Class: TransactionEntries (_exports_TransactionEntries) */
// jsnapi_registerclass
Napi::Function _exports_TransactionEntries_ctor = _exports_TransactionEntries_inst::GetClass(env);
exports.Set("TransactionEntries", _exports_TransactionEntries_ctor);
if (SWIGTYPE_p_std__vectorT_std__shared_ptrT_gradido__blockchain__TransactionEntry_t_t->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_std__vectorT_std__shared_ptrT_gradido__blockchain__TransactionEntry_t_t->clientdata = new size_t(28);
}
Napi::FunctionReference *_exports_TransactionEntries_ctor_ref = new Napi::FunctionReference();
*_exports_TransactionEntries_ctor_ref = Napi::Persistent(_exports_TransactionEntries_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[28] = _exports_TransactionEntries_ctor_ref;
/* Class: TransactionEntry (_exports_TransactionEntry) */
// jsnapi_registerclass
Napi::Function _exports_TransactionEntry_ctor = _exports_TransactionEntry_inst::GetClass(env);
exports.Set("TransactionEntry", _exports_TransactionEntry_ctor);
if (SWIGTYPE_p_gradido__blockchain__TransactionEntry->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__blockchain__TransactionEntry->clientdata = new size_t(29);
}
Napi::FunctionReference *_exports_TransactionEntry_ctor_ref = new Napi::FunctionReference();
*_exports_TransactionEntry_ctor_ref = Napi::Persistent(_exports_TransactionEntry_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[29] = _exports_TransactionEntry_ctor_ref;
/* Class: Pagination (_exports_Pagination) */
// jsnapi_registerclass
Napi::Function _exports_Pagination_ctor = _exports_Pagination_inst::GetClass(env);
exports.Set("Pagination", _exports_Pagination_ctor);
if (SWIGTYPE_p_gradido__blockchain__Pagination->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__blockchain__Pagination->clientdata = new size_t(30);
}
Napi::FunctionReference *_exports_Pagination_ctor_ref = new Napi::FunctionReference();
*_exports_Pagination_ctor_ref = Napi::Persistent(_exports_Pagination_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[30] = _exports_Pagination_ctor_ref;
/* Class: Filter (_exports_Filter) */
// jsnapi_registerclass
Napi::Function _exports_Filter_ctor = _exports_Filter_inst::GetClass(env);
exports.Set("Filter", _exports_Filter_ctor);
if (SWIGTYPE_p_gradido__blockchain__Filter->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__blockchain__Filter->clientdata = new size_t(31);
}
Napi::FunctionReference *_exports_Filter_ctor_ref = new Napi::FunctionReference();
*_exports_Filter_ctor_ref = Napi::Persistent(_exports_Filter_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[31] = _exports_Filter_ctor_ref;
/* Class: FilterBuilder (_exports_FilterBuilder) */
// jsnapi_registerclass
Napi::Function _exports_FilterBuilder_ctor = _exports_FilterBuilder_inst::GetClass(env);
exports.Set("FilterBuilder", _exports_FilterBuilder_ctor);
if (SWIGTYPE_p_gradido__blockchain__FilterBuilder->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__blockchain__FilterBuilder->clientdata = new size_t(32);
}
Napi::FunctionReference *_exports_FilterBuilder_ctor_ref = new Napi::FunctionReference();
*_exports_FilterBuilder_ctor_ref = Napi::Persistent(_exports_FilterBuilder_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[32] = _exports_FilterBuilder_ctor_ref;
/* Class: DeferredRedeemedTransferPair (_exports_DeferredRedeemedTransferPair) */
// jsnapi_registerclass
Napi::Function _exports_DeferredRedeemedTransferPair_ctor = _exports_DeferredRedeemedTransferPair_inst::GetClass(env);
exports.Set("DeferredRedeemedTransferPair", _exports_DeferredRedeemedTransferPair_ctor);
if (SWIGTYPE_p_std__pairT_std__shared_ptrT_gradido__blockchain__TransactionEntry_t_std__shared_ptrT_gradido__blockchain__TransactionEntry_t_t->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_std__pairT_std__shared_ptrT_gradido__blockchain__TransactionEntry_t_std__shared_ptrT_gradido__blockchain__TransactionEntry_t_t->clientdata = new size_t(33);
}
Napi::FunctionReference *_exports_DeferredRedeemedTransferPair_ctor_ref = new Napi::FunctionReference();
*_exports_DeferredRedeemedTransferPair_ctor_ref = Napi::Persistent(_exports_DeferredRedeemedTransferPair_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[33] = _exports_DeferredRedeemedTransferPair_ctor_ref;
/* Class: Abstract (_exports_Abstract) */
// jsnapi_registerclass
Napi::Function _exports_Abstract_ctor = _exports_Abstract_inst::GetClass(env);
exports.Set("Abstract", _exports_Abstract_ctor);
if (SWIGTYPE_p_gradido__blockchain__Abstract->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__blockchain__Abstract->clientdata = new size_t(34);
}
Napi::FunctionReference *_exports_Abstract_ctor_ref = new Napi::FunctionReference();
*_exports_Abstract_ctor_ref = Napi::Persistent(_exports_Abstract_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[34] = _exports_Abstract_ctor_ref;
/* Class: InMemoryBlockchain (_exports_InMemoryBlockchain) */
// jsnapi_registerclass
Napi::Function _exports_InMemoryBlockchain_ctor = _exports_InMemoryBlockchain_inst::GetClass(env);
exports.Set("InMemoryBlockchain", _exports_InMemoryBlockchain_ctor);
if (SWIGTYPE_p_gradido__blockchain__InMemory->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__blockchain__InMemory->clientdata = new size_t(35);
}
Napi::FunctionReference *_exports_InMemoryBlockchain_ctor_ref = new Napi::FunctionReference();
*_exports_InMemoryBlockchain_ctor_ref = Napi::Persistent(_exports_InMemoryBlockchain_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[35] = _exports_InMemoryBlockchain_ctor_ref;
/* Class: InMemoryBlockchainProvider (_exports_InMemoryBlockchainProvider) */
// jsnapi_registerclass
Napi::Function _exports_InMemoryBlockchainProvider_ctor = _exports_InMemoryBlockchainProvider_inst::GetClass(env);
exports.Set("InMemoryBlockchainProvider", _exports_InMemoryBlockchainProvider_ctor);
if (SWIGTYPE_p_gradido__blockchain__InMemoryProvider->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__blockchain__InMemoryProvider->clientdata = new size_t(36);
}
Napi::FunctionReference *_exports_InMemoryBlockchainProvider_ctor_ref = new Napi::FunctionReference();
*_exports_InMemoryBlockchainProvider_ctor_ref = Napi::Persistent(_exports_InMemoryBlockchainProvider_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[36] = _exports_InMemoryBlockchainProvider_ctor_ref;
/* Class: InteractionToJson (_exports_InteractionToJson) */
// jsnapi_registerclass
Napi::Function _exports_InteractionToJson_ctor = _exports_InteractionToJson_inst::GetClass(env);
exports.Set("InteractionToJson", _exports_InteractionToJson_ctor);
if (SWIGTYPE_p_gradido__interaction__toJson__Context->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__interaction__toJson__Context->clientdata = new size_t(37);
}
Napi::FunctionReference *_exports_InteractionToJson_ctor_ref = new Napi::FunctionReference();
*_exports_InteractionToJson_ctor_ref = Napi::Persistent(_exports_InteractionToJson_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[37] = _exports_InteractionToJson_ctor_ref;
/* Class: InteractionCalculateAccountBalance (_exports_InteractionCalculateAccountBalance) */
// jsnapi_registerclass
Napi::Function _exports_InteractionCalculateAccountBalance_ctor = _exports_InteractionCalculateAccountBalance_inst::GetClass(env);
exports.Set("InteractionCalculateAccountBalance", _exports_InteractionCalculateAccountBalance_ctor);
if (SWIGTYPE_p_gradido__interaction__calculateAccountBalance__Context->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__interaction__calculateAccountBalance__Context->clientdata = new size_t(38);
}
Napi::FunctionReference *_exports_InteractionCalculateAccountBalance_ctor_ref = new Napi::FunctionReference();
*_exports_InteractionCalculateAccountBalance_ctor_ref = Napi::Persistent(_exports_InteractionCalculateAccountBalance_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[38] = _exports_InteractionCalculateAccountBalance_ctor_ref;
/* Class: InteractionValidate (_exports_InteractionValidate) */
// jsnapi_registerclass
Napi::Function _exports_InteractionValidate_ctor = _exports_InteractionValidate_inst::GetClass(env);
exports.Set("InteractionValidate", _exports_InteractionValidate_ctor);
if (SWIGTYPE_p_gradido__interaction__validate__Context->clientdata == SWIG_NULLPTR) {
  SWIGTYPE_p_gradido__interaction__validate__Context->clientdata = new size_t(39);
}
Napi::FunctionReference *_exports_InteractionValidate_ctor_ref = new Napi::FunctionReference();
*_exports_InteractionValidate_ctor_ref = Napi::Persistent(_exports_InteractionValidate_ctor);
env.GetInstanceData<EnvInstanceData>()->ctor[39] = _exports_InteractionValidate_ctor_ref;


  /* initialize the inheritance helpers */
  Napi::Value jsObjectValue, jsSetProtoValue;
  Napi::Object jsObject;
  Napi::Function setProto;
  NAPI_CHECK_RESULT(env.Global().Get("Object"), jsObjectValue);
  NAPI_CHECK_RESULT(jsObjectValue.ToObject(), jsObject);
  NAPI_CHECK_RESULT(jsObject.Get("setPrototypeOf"), jsSetProtoValue);
  setProto = jsSetProtoValue.As<Napi::Function>();

  /* setup inheritance between these two */
  do {
    Napi::Value protoBase, protoSub;
    NAPI_CHECK_RESULT(SWIG_NAPI_PackedObjectWrap_ctor.Get("prototype"), protoSub);
    NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
    NAPI_CHECK_MAYBE(setProto.Call({SWIG_NAPI_PackedObjectWrap_ctor, SWIG_NAPI_ObjectWrap_ctor}));
    NAPI_CHECK_MAYBE(setProto.Call({protoSub, protoBase}));
  } while (0);

  /* setup inheritances */
  
// Inheritance for _exports_TimepointInterval (TimepointInterval) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_TimepointInterval_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_TimepointInterval_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_Profiler (Profiler) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_Profiler_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_Profiler_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_MemoryBlocks (MemoryBlocks) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_MemoryBlocks_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_MemoryBlocks_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_MemoryBlock (MemoryBlock) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_MemoryBlock_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_MemoryBlock_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_Passphrase (Passphrase) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_Passphrase_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_Passphrase_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_SecretKeyCryptography (SecretKeyCryptography) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_SecretKeyCryptography_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_SecretKeyCryptography_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_KeyPairEd25519 (KeyPairEd25519) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_KeyPairEd25519_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_KeyPairEd25519_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_KeyPairEd25519Ex (KeyPairEd25519Ex) <- _exports_KeyPairEd25519
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_KeyPairEd25519Ex_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(_exports_KeyPairEd25519_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_KeyPairEd25519Ex_ctor, _exports_KeyPairEd25519_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_AuthenticatedEncryption (AuthenticatedEncryption) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_AuthenticatedEncryption_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_AuthenticatedEncryption_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_GradidoUnit (GradidoUnit) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_GradidoUnit_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_GradidoUnit_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_SignaturePairs (SignaturePairs) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_SignaturePairs_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_SignaturePairs_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_TransferAmount (TransferAmount) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_TransferAmount_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_TransferAmount_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_TimestampSeconds (TimestampSeconds) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_TimestampSeconds_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_TimestampSeconds_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_Timestamp (Timestamp) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_Timestamp_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_Timestamp_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_SignaturePair (SignaturePair) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_SignaturePair_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_SignaturePair_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_SignatureMap (SignatureMap) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_SignatureMap_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_SignatureMap_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_CommunityFriendsUpdate (CommunityFriendsUpdate) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_CommunityFriendsUpdate_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_CommunityFriendsUpdate_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_CommunityRoot (CommunityRoot) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_CommunityRoot_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_CommunityRoot_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_GradidoCreation (GradidoCreation) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_GradidoCreation_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_GradidoCreation_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_GradidoTransfer (GradidoTransfer) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_GradidoTransfer_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_GradidoTransfer_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_GradidoDeferredTransfer (GradidoDeferredTransfer) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_GradidoDeferredTransfer_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_GradidoDeferredTransfer_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_RegisterAddress (RegisterAddress) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_RegisterAddress_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_RegisterAddress_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_TransactionBody (TransactionBody) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_TransactionBody_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_TransactionBody_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_GradidoTransaction (GradidoTransaction) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_GradidoTransaction_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_GradidoTransaction_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_ConfirmedTransaction (ConfirmedTransaction) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_ConfirmedTransaction_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_ConfirmedTransaction_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_GradidoTransactionBuilder (GradidoTransactionBuilder) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_GradidoTransactionBuilder_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_GradidoTransactionBuilder_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_InteractionDeserialize (InteractionDeserialize) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_InteractionDeserialize_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_InteractionDeserialize_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_InteractionSerialize (InteractionSerialize) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_InteractionSerialize_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_InteractionSerialize_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_TransactionEntries (TransactionEntries) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_TransactionEntries_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_TransactionEntries_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_TransactionEntry (TransactionEntry) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_TransactionEntry_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_TransactionEntry_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_Pagination (Pagination) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_Pagination_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_Pagination_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_Filter (Filter) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_Filter_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_Filter_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_FilterBuilder (FilterBuilder) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_FilterBuilder_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_FilterBuilder_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_DeferredRedeemedTransferPair (DeferredRedeemedTransferPair) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_DeferredRedeemedTransferPair_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_DeferredRedeemedTransferPair_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_Abstract (Abstract) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_Abstract_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_Abstract_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_InMemoryBlockchain (InMemoryBlockchain) <- _exports_Abstract
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_InMemoryBlockchain_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(_exports_Abstract_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_InMemoryBlockchain_ctor, _exports_Abstract_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_InMemoryBlockchainProvider (InMemoryBlockchainProvider) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_InMemoryBlockchainProvider_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_InMemoryBlockchainProvider_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_InteractionToJson (InteractionToJson) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_InteractionToJson_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_InteractionToJson_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_InteractionCalculateAccountBalance (InteractionCalculateAccountBalance) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_InteractionCalculateAccountBalance_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_InteractionCalculateAccountBalance_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);


// Inheritance for _exports_InteractionValidate (InteractionValidate) <- SWIG_NAPI_ObjectWrap
// jsnapi_setup_inheritance
do {
  Napi::Value protoBase, protoSub;
  NAPI_CHECK_RESULT(_exports_InteractionValidate_ctor.Get("prototype"), protoSub);
  NAPI_CHECK_RESULT(SWIG_NAPI_ObjectWrap_ctor.Get("prototype"), protoBase);
  NAPI_CHECK_MAYBE(setProto.Call({
    _exports_InteractionValidate_ctor, SWIG_NAPI_ObjectWrap_ctor
  }));
  NAPI_CHECK_MAYBE(setProto.Call({
    protoSub, protoBase
  }));
} while (0);



  /* create and register namespace objects */
  // jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_AddressType_NONE_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("AddressType_NONE", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_AddressType_COMMUNITY_HUMAN_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("AddressType_COMMUNITY_HUMAN", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_AddressType_COMMUNITY_GMW_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("AddressType_COMMUNITY_GMW", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_AddressType_COMMUNITY_AUF_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("AddressType_COMMUNITY_AUF", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_AddressType_COMMUNITY_PROJECT_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("AddressType_COMMUNITY_PROJECT", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_AddressType_SUBACCOUNT_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("AddressType_SUBACCOUNT", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_AddressType_CRYPTO_ACCOUNT_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("AddressType_CRYPTO_ACCOUNT", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_CrossGroupType_LOCAL_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("CrossGroupType_LOCAL", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_CrossGroupType_INBOUND_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("CrossGroupType_INBOUND", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_CrossGroupType_OUTBOUND_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("CrossGroupType_OUTBOUND", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_CrossGroupType_CROSS_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("CrossGroupType_CROSS", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_TransactionType_NONE_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("TransactionType_NONE", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_TransactionType_CREATION_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("TransactionType_CREATION", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_TransactionType_TRANSFER_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("TransactionType_TRANSFER", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_TransactionType_COMMUNITY_FRIENDS_UPDATE_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("TransactionType_COMMUNITY_FRIENDS_UPDATE", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_TransactionType_REGISTER_ADDRESS_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("TransactionType_REGISTER_ADDRESS", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_TransactionType_DEFERRED_TRANSFER_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("TransactionType_DEFERRED_TRANSFER", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_TransactionType_COMMUNITY_ROOT_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("TransactionType_COMMUNITY_ROOT", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_function
do {
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Function("addressTypeToString", _wrap_addressTypeToString,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_function
do {
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Function("crossGroupTypeToString", _wrap_crossGroupTypeToString,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_function
do {
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Function("transactionTypeToString", _wrap_transactionTypeToString,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_MnemonicType_GRADIDO_BOOK_GERMAN_RANDOM_ORDER_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("MnemonicType_GRADIDO_BOOK_GERMAN_RANDOM_ORDER", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_MnemonicType_GRADIDO_BOOK_GERMAN_RANDOM_ORDER_FIXED_CASES_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("MnemonicType_GRADIDO_BOOK_GERMAN_RANDOM_ORDER_FIXED_CASES", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_MnemonicType_BIP0039_SORTED_ORDER_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("MnemonicType_BIP0039_SORTED_ORDER", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_MnemonicType_MAX_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("MnemonicType_MAX", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_function
do {
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Function("loadCryptoKeys", _wrap_loadCryptoKeys,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_function
do {
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Function("ed25519DerivationTypeToString", _wrap_ed25519DerivationTypeToString,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_Ed25519DerivationType_SOFT_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("Ed25519DerivationType_SOFT", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_Ed25519DerivationType_HARD_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("Ed25519DerivationType_HARD", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_ED25519_CHAIN_CODE_SIZE_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("ED25519_CHAIN_CODE_SIZE", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_function
do {
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Function("SealedBoxEncrypt", _wrap_SealedBoxEncrypt,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_function
do {
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Function("SealedBoxDecrypt", _wrap_SealedBoxes__wrap_SealedBoxDecrypt,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_DeserializeType_UNKNOWN_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("DeserializeType_UNKNOWN", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_DeserializeType_TRANSACTION_BODY_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("DeserializeType_TRANSACTION_BODY", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_DeserializeType_GRADIDO_TRANSACTION_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("DeserializeType_GRADIDO_TRANSACTION", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_DeserializeType_CONFIRMED_TRANSACTION_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("DeserializeType_CONFIRMED_TRANSACTION", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_DeserializeType_MAX_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("DeserializeType_MAX", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_function
do {
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Function("deserializeTypeToString", _wrap_deserializeTypeToString,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_FilterResult_USE_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("FilterResult_USE", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_FilterResult_DISMISS_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("FilterResult_DISMISS", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_FilterResult_STOP_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("FilterResult_STOP", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_SearchDirection_ASC_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("SearchDirection_ASC", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_SearchDirection_DESC_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("SearchDirection_DESC", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_function
do {
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Function("searchDirectionToString", _wrap_searchDirectionToString,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_BodyBytesType_BASE64_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("BodyBytesType_BASE64", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_BodyBytesType_HEX_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("BodyBytesType_HEX", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_BodyBytesType_JSON_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("BodyBytesType_JSON", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_function
do {
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Function("bodyBytesTypeToString", _wrap_bodyBytesTypeToString,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_ValidateType_SINGLE_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("ValidateType_SINGLE", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_ValidateType_PREVIOUS_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("ValidateType_PREVIOUS", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_ValidateType_MONTH_RANGE_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("ValidateType_MONTH_RANGE", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_ValidateType_PAIRED_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("ValidateType_PAIRED", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_ValidateType_ACCOUNT_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("ValidateType_ACCOUNT", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_ValidateType_CONNECTED_GROUP_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("ValidateType_CONNECTED_GROUP", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_constant
do {
  Napi::Function f = Napi::Function::New(env, exports_ValidateType_CONNECTED_BLOCKCHAIN_get);
  Napi::Value value;
  NAPI_CHECK_RESULT(f.Call(0, SWIG_NULLPTR), value);
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Value("ValidateType_CONNECTED_BLOCKCHAIN", value,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);
// jsnapi_register_global_function
do {
  Napi::PropertyDescriptor pd = Napi::PropertyDescriptor::Function("validateTypeToString", _wrap_validateTypeToString,
    static_cast<napi_property_attributes>(napi_writable | napi_enumerable | napi_configurable));
  NAPI_CHECK_MAYBE(exports.DefineProperty(pd));
} while (0);


  return exports;
  goto fail;
fail:
  return Napi::Object();
}

NODE_API_MODULE(gradido, Init)
